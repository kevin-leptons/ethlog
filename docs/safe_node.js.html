<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>safe_node.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Address.html">Address</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Address.html#.fromBuffer">fromBuffer</a></li><li data-type='method' style='display: none;'><a href="Address.html#.fromHeximal">fromHeximal</a></li><li data-type='method' style='display: none;'><a href="Address.html#toHeximal">toHeximal</a></li></ul></li><li><a href="BadError.html">BadError</a><ul class='methods'><li data-type='method' style='display: none;'><a href="BadError.html#.noData">noData</a></li><li data-type='method' style='display: none;'><a href="BadError.html#.noMessage">noMessage</a></li></ul></li><li><a href="Block.html">Block</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Block.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="Block.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="ByteData.html">ByteData</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ByteData.html#.fromBadHeximal">fromBadHeximal</a></li><li data-type='method' style='display: none;'><a href="ByteData.html#.fromBuffer">fromBuffer</a></li><li data-type='method' style='display: none;'><a href="ByteData.html#.fromHeximal">fromHeximal</a></li><li data-type='method' style='display: none;'><a href="ByteData.html#eq">eq</a></li></ul></li><li><a href="ByteData32.html">ByteData32</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ByteData32.html#eq">eq</a></li><li data-type='method' style='display: none;'><a href="ByteData32.html#toHeximal">toHeximal</a></li><li data-type='method' style='display: none;'><a href="ByteData32.html#.fromBuffer">fromBuffer</a></li><li data-type='method' style='display: none;'><a href="ByteData32.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Client.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="Client.html#call">call</a></li><li data-type='method' style='display: none;'><a href="Client.html#getBlockByNumber">getBlockByNumber</a></li><li data-type='method' style='display: none;'><a href="Client.html#getBlockNumber">getBlockNumber</a></li><li data-type='method' style='display: none;'><a href="Client.html#getLogs">getLogs</a></li><li data-type='method' style='display: none;'><a href="Client.html#getTransactionByHash">getTransactionByHash</a></li></ul></li><li><a href="Codec.html">Codec</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Codec.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="Codec.html#.fromJsonFile">fromJsonFile</a></li><li data-type='method' style='display: none;'><a href="Codec.html#decodeFunctionResult">decodeFunctionResult</a></li><li data-type='method' style='display: none;'><a href="Codec.html#encodeFunctionData">encodeFunctionData</a></li><li data-type='method' style='display: none;'><a href="Codec.html#getEventTopic">getEventTopic</a></li><li data-type='method' style='display: none;'><a href="Codec.html#parseLog">parseLog</a></li></ul></li><li><a href="Contract.html">Contract</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Contract.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="Contract.html#call">call</a></li></ul></li><li><a href="EndpointQuota.html">EndpointQuota</a><ul class='methods'><li data-type='method' style='display: none;'><a href="EndpointQuota.html#.create">create</a></li></ul></li><li><a href="EthEndpoint.html">EthEndpoint</a><ul class='methods'><li data-type='method' style='display: none;'><a href="EthEndpoint.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="EthEndpoint.html#.validateUniqueItems">validateUniqueItems</a></li><li data-type='method' style='display: none;'><a href="EthEndpoint.html#.validateUniqueLists">validateUniqueLists</a></li></ul></li><li><a href="Gateway.html">Gateway</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Gateway.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="Gateway.html#proxy">proxy</a></li></ul></li><li><a href="HttpEndpoint.html">HttpEndpoint</a><ul class='methods'><li data-type='method' style='display: none;'><a href="HttpEndpoint.html#.create">create</a></li></ul></li><li><a href="HttpResponse.html">HttpResponse</a><ul class='methods'><li data-type='method' style='display: none;'><a href="HttpResponse.html#.fromAxiosResponse">fromAxiosResponse</a></li></ul></li><li><a href="HttpUrl.html">HttpUrl</a><ul class='methods'><li data-type='method' style='display: none;'><a href="HttpUrl.html#.fromString">fromString</a></li></ul></li><li><a href="JsonResponse.html">JsonResponse</a><ul class='methods'><li data-type='method' style='display: none;'><a href="JsonResponse.html#.fromHttpResponse">fromHttpResponse</a></li></ul></li><li><a href="Log.html">Log</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Log.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="LogFilter.html">LogFilter</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LogFilter.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="LogFilter.html#toRpcInput">toRpcInput</a></li></ul></li><li><a href="LogSegment.html">LogSegment</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LogSegment.html#.create">create</a></li></ul></li><li><a href="LogStream.html">LogStream</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LogStream.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="LogStream.html#start">start</a></li></ul></li><li><a href="LogTopicCombination.html">LogTopicCombination</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LogTopicCombination.html#.fromRpcResult">fromRpcResult</a></li><li data-type='method' style='display: none;'><a href="LogTopicCombination.html#toHeximalArray">toHeximalArray</a></li></ul></li><li><a href="LogTopicFilter.html">LogTopicFilter</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LogTopicFilter.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="LogTopicFilter.html#toRpcInput">toRpcInput</a></li></ul></li><li><a href="Node.html">Node</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Node.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="Node.html#call">call</a></li><li data-type='method' style='display: none;'><a href="Node.html#getBlockByNumber">getBlockByNumber</a></li><li data-type='method' style='display: none;'><a href="Node.html#getBlockNumber">getBlockNumber</a></li><li data-type='method' style='display: none;'><a href="Node.html#getLogs">getLogs</a></li><li data-type='method' style='display: none;'><a href="Node.html#getTransactionByHash">getTransactionByHash</a></li></ul></li><li><a href="NodeResponse.html">NodeResponse</a><ul class='methods'><li data-type='method' style='display: none;'><a href="NodeResponse.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="NodeResponse.html#cloneWithNewData">cloneWithNewData</a></li></ul></li><li><a href="RequestValve.html">RequestValve</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RequestValve.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="RequestValve.html#downLogRange">downLogRange</a></li><li data-type='method' style='display: none;'><a href="RequestValve.html#giveBackQuota">giveBackQuota</a></li><li data-type='method' style='display: none;'><a href="RequestValve.html#open">open</a></li><li data-type='method' style='display: none;'><a href="RequestValve.html#reportError">reportError</a></li><li data-type='method' style='display: none;'><a href="RequestValve.html#setLatestBlockNumber">setLatestBlockNumber</a></li><li data-type='method' style='display: none;'><a href="RequestValve.html#updateLogRange">updateLogRange</a></li></ul></li><li><a href="RpcResponse.html">RpcResponse</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RpcResponse.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="RpcResponse.html#.fromJsonResponse">fromJsonResponse</a></li></ul></li><li><a href="SafeNode.html">SafeNode</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SafeNode.html#.create">create</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#call">call</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#getBlockByNumber">getBlockByNumber</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#getBlockNumber">getBlockNumber</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#getLogs">getLogs</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#getTransactionByHash">getTransactionByHash</a></li></ul></li><li><a href="Transaction.html">Transaction</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Transaction.html#.fromRpcResult">fromRpcResult</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#BadHeximal">BadHeximal</a></li><li><a href="global.html#ErrorCode">ErrorCode</a></li><li><a href="global.html#ErrorString">ErrorString</a></li><li><a href="global.html#EstimatedLogRange">EstimatedLogRange</a></li><li><a href="global.html#getInvertedObject">getInvertedObject</a></li><li><a href="global.html#heximalToBuffer">heximalToBuffer</a></li><li><a href="global.html#heximalToFixedBuffer">heximalToFixedBuffer</a></li><li><a href="global.html#LogHandler">LogHandler</a></li><li><a href="global.html#LogLevel">LogLevel</a></li><li><a href="global.html#SafeBlockInfo">SafeBlockInfo</a></li><li><a href="global.html#SafeLogFilter">SafeLogFilter</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">safe_node.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const {Log: StdioLog} = require('stdio_log')
const {Node, NodeResponse} = require('./node')
const {
    UInt,
    UInt64,
    PInt64,
    Timespan,
    Timestamp,
    DataSize,
    validateInstanceMap,
    validateArrayItems,
    validateInstance
} = require('minitype')
const {
    BadError,
    Result,
    ByteData32,
    EthEndpoint,
    HttpEndpoint,
    EndpointQuota,
    Block,
    LogFilter,
    Log,
    Transaction,
    BigMath
} = require('./type')
const {
    NODE_OVERLOADING,
    NODE_BAD_RESPONSE,
    NODE_BAD_SERVER,
    NODE_UNSAFE_BLOCK,
    NODE_REQUEST_QUOTA
} = require('./type').ErrorCode

const UINT_1 = UInt.fromNumber(1).open()
const UINT_2 = UInt.fromNumber(2).open()
const SECONDS_6 = Timespan.fromSeconds(6).open()
const SECONDS_15 = Timespan.fromSeconds(15).open()
const SECONDS_30 = Timespan.fromSeconds(30).open()
const MINUTES_1 = Timespan.fromMinutes(1).open()

/**
 * @typedef {object} SafeBlockInfo
 * @property {UInt64} safeBlock
 * @property {UInt64} latestBlock
 */

/**
 * @typedef {object} SafeLogFilter
 * @property {LogFilter} filter
 * @property {UInt64} latestBlock
 * @property {UInt64} safeBlock
 */

/**
 * @typedef {object} EstimatedLogRange
 * @property {UInt64} bySize
 * @property {UInt64} byTimespan
 * @property {UInt64} byQuantity
 */

/**
 * Contain logs and related information for a result of logs query.
 */
class LogSegment {
    /**
     * List of logs in range `[fromBlock, toBlock]`.
     *
     * @type {Array&lt;Log>}
     */
    get logs() {
        return this._logs
    }

    /**
     * Confirm that logs is fetch from this block number.
     *
     * @type {UInt64}
     */
    get fromBlock() {
        return this._fromBlock
    }

    /**
     * Confirm that logs is fetch to this block number, inclusive.  In next
     * query, it is safe for retrieving from block number `toBlock + 1` without
     * worry about missing logs.
     *
     * @type {UInt64}
     */
    get toBlock() {
        return this._toBlock
    }

    /**
     * Latest mined block number at query node.
     *
     * @type {UInt64}
     */
    get latestBlock() {
        return this._latestBlock
    }

    /**
     * Latest and safe block number.
     *
     * @type {UInt64}
     */
    get safeBlock() {
        return this._safeBlock
    }

    /**
     * Initialize by {@link LogSegment.create}.
     *
     * @param {object} values
     * @param {Array&lt;Log>} values.logs
     * @param {UInt64} values.fromBlock
     * @param {UInt64} values.toBlock
     * @param {UInt64} values.latestBlock
     * @param {UInt64} values.safeBlock
     */
    constructor(values) {
        this._logs = values.logs
        this._fromBlock = values.fromBlock
        this._toBlock = values.toBlock
        this._latestBlock = values.latestBlock
        this._safeBlock = values.safeBlock
    }

    /**
     *
     * @param {object} object
     * @param {Array&lt;Log>} object.logs - List of matched logs by filter.
     * @param {UInt64} object.fromBlock - Retrieve logs from this block
     * number.
     * @param {UInt64} object.toBlock - Confirm logs correctness in
     * range `[fromBlock, toBlock]`.
     * @param {UInt64} object.latestBlock - Latest block number at served node.
     * @param {UInt64} object.safeBlock - Latest and safe block number at served
     * node.
     * @return {Result&lt;string, LogSegment>}
     */
    static create(object) {
        let r1 = validateInstanceMap(object, [
            ['logs', Array],
            ['fromBlock', UInt64],
            ['toBlock', UInt64],
            ['latestBlock', UInt64],
            ['safeBlock', UInt64]
        ])
        if (r1.error) {
            return r1
        }
        let r2 = validateArrayItems(object.logs, Log)
        if (r2.error) {
            return Result.errro(`logs: ${r2.error}`)
        }
        let data = new LogSegment(object)
        return Result.ok(data)
    }
}

/**
 * Control quota, log range for requests to Ethereum node. Also lock queries for
 * critical errors such as bad request, bad response and overloading.
 *
 * @example
 * let valve = RequestValve.create()
 *
 * // Update state by.
 * valve.updateLogRange()
 * valve.downLogRange()
 * value.reportError()
 *
 * // Ask for performing requests to Ethereum node.
 * valve.open()
 *
 * // Retrieve estimated log range.
 * valve.logRange()
 */
class RequestValve {
    /**
     * Estimated log range from previous query result by
     * {@link RequestValve.updateLogRange}. Then, this value is consider for
     * setup log filter.
     *
     * @type {PInt64}
     */
    get logRange() {
        return PInt64.fromBigInt(this._logRange).open()
    }

    /**
     * @type {UInt64 | undefined}
     */
    get safeBlockNumber() {
        return this._safeBlockNumber
    }

    /**
     * Initialize by {@link RequestValve.create}.
     *
     * @param {object} config
     * @param {EndpointQuota} config.quota
     * @param {StdioLog} config.log
     * @param {UInt64} config.logSafeGap
     * @param {UInt64} config.rangeBoundary
     * @param {DataSize} config.logSizeBorder
     * @param {Timespan} config.logTimeBorder
     * @param {UInt64} config.logQuantityBorder
     */
    constructor(config) {
        let {
            quota: {batchLimit, batchTimespan},
            log,
            logSafeGap,
            logRangeBoundary,
            logSizeBorder,
            logTimeBorder,
            logQuantityBorder
        } = config
        this._log = log
        this._logSafeGap = logSafeGap
        this._batchLimit = batchLimit
        this._batchTimespan = batchTimespan
        this._logRangeBoundary = logRangeBoundary
        this._logSizeBorder = logSizeBorder
        this._logTimeBorder = logTimeBorder
        this._logQuantityBorder = logQuantityBorder
        this._logRange = 10n
    }

    /**
     *
     * @param {object} config
     * @param {EndpointQuota} config.quota
     * @param {StdioLog} config.log
     * @param {UInt64} [config.logSafeGap=15]
     * @param {UInt64} [config.logRangeBoundary=5,000]
     * @param {DataSize} [config.logSizeBorder=4MB]
     * @param {Timespan} [config.logTimeBorder=6s]
     * @param {UInt64} [config.logQuantityBorder=10,000]
     * @return {Result&lt;TypeError, RequestValve>}
     */
    static create(config) {
        let r1 = validateInstanceMap(config, [
            ['quota', EndpointQuota],
            ['log', StdioLog],
            ['logSafeGap', UInt64, true],
            ['logRangeBoundary', UInt64, true],
            ['logSizeBorder', DataSize, true],
            ['logTimeBorder', Timespan, true],
            ['logQuantityBorder', UInt64, true]
        ])
        if (r1.error) {
            return r1
        }
        let {
            quota, log, logSafeGap, logRangeBoundary, logSizeBorder,
            logTimeBorder, logQuantityBorder
        } = config
        logSafeGap = logSafeGap || UInt64.fromNumber(15).open()
        logRangeBoundary = logRangeBoundary || UInt64.fromNumber(5000).open()
        logSizeBorder = logSizeBorder || DataSize.fromMegabytes(4).open()
        logTimeBorder = logTimeBorder || Timespan.fromSeconds(6).open()
        logQuantityBorder = logQuantityBorder || UInt64.fromNumber(10000).open()
        let instance = new RequestValve({
            quota, log, logSafeGap, logRangeBoundary, logSizeBorder,
            logTimeBorder, logQuantityBorder
        })
        return Result.ok(instance)
    }

    /**
     * Ask for performing queries to a ETH node. Succeeded result means request
     * quota is enough and the node is not lock by reasons.
     *
     * @param {UInt} quantity - Quantities of requests will be use.
     * @param {UInt64} blockNumber - The block number that query will be
     * involve. If it is not a safe block certainly then return failed result.
     * If there is a safe block, or unable for confirmation then returned result
     * depend on rest of conditions. Give `undefined` mean skip this condition.
     * @return {Result&lt;undefined>}
     */
    open(quantity, blockNumber = undefined) {
        this._updateInternalStat()
        let r1 = this._openTimestampLocker()
        if (r1.error) {
            return r1
        }
        let r2 = this._openForSafeBlockNumber(blockNumber)
        if (r2.error) {
            return r2
        }
        let r3 = this._openQuotaLocker(quantity)
        if (r3.error) {
            return r3
        }
        return Result.ok()
    }

    /**
     * Set the latest block number which is returned from the node. The value is
     * use to find out safe block number and evaluate locking for the requests
     * that requires greater block number.
     *
     * The safe block number can be retrieve by
     * {@link RequestValve.safeBlockNumber}.
     *
     * @param {UInt64} blockNumber
     * @throws {TypeError}
     */
    setLatestBlockNumber(blockNumber) {
        validateInstance(blockNumber, UInt64).open()
        this._latestBlockNumber = blockNumber
        if (blockNumber.lt(this._logSafeGap)) {
            this._safeBlockNumber = undefined
            return
        }
        this._safeBlockNumber = blockNumber.sub(this._logSafeGap)
        this._safeBlockNumberTo = Timestamp.now().add(SECONDS_6)
    }

    /**
     * Give back request quota after ask for consumption by
     * {@link SafeNode.open}.
     *
     * @param {UInt} quantity
     */
    giveBackQuota(quantity) {
        this._remainRequests = this._remainRequests.add(quantity)
    }

    /**
     * Evaluate errors for estimation log range and locking queries.
     *
     * @param {BadError} error
     */
    reportError(error) {
        switch (error.code) {
            case NODE_BAD_SERVER:
                this._handleBadServer(error)
                break
            case NODE_BAD_RESPONSE:
                this._handleBadResponse(error)
                break
            case NODE_OVERLOADING:
                this._handleOverloading(error)
                break
            default:
                this._log.error(error.message)
        }
    }

    /**
     * Estimate log range but will not set it greater than `_logRangeBoundary`.
     * Result can be retrieve by `logRange`.
     *
     * @param {NodeResponse&lt;LogSegment>} logResponse
     */
    updateLogRange(logResponse) {
        let {bySize, byTimespan, byQuantity} =
            this._estimateLogRange(logResponse)
        let logRange = BigMath.min(
            bySize.value, byTimespan.value, byQuantity.value,
            this._logRangeBoundary.value
        )
        if (
            logRange > this._logRange &amp;&amp;
            this._lockRangeUpTo &amp;&amp;
            this._lockRangeUpTo.isFuture()
        ) {
            return
        }
        this._printLogResponse(logResponse)
        this._printEstimatedLogRange(bySize, byTimespan, byQuantity)
        this._logRange = logRange
        this._log.info('set log range', this._logRange)
    }

    /**
     * Decrease log range but will not set it less than `1`.
     */
    downLogRange() {
        this._logRange = BigMath.max(this._logRange / 2n, 1n)
        this._lockRangeUpTo = Timestamp.now().add(MINUTES_1)
        this._log.info('set log range', this._logRange)
    }

    /**
     * @private
     * @param {BadError} error
     */
    _handleBadServer(error) {
        this._lockTimestampFor(error, SECONDS_30)
    }

    /**
     * @private
     * @param {BadError} error
     */
    _handleBadResponse(error) {
        this._lockTimestampFor(error, SECONDS_30)
    }

    /**
     * @private
     * @param {BadError} error
     */
    _handleOverloading(error) {
        this._lockTimestampFor(error, SECONDS_15)
        this.downLogRange()
    }

    /**
     * @private
     * @param {NodeResponse&lt;LogSegment>} logResponse
     * @return {EstimatedLogRange}
     */
    _estimateLogRange(logResponse) {
        let {
            logs,
            fromBlock: {value: fromBlock},
            toBlock: {value: toBlock}
        } = logResponse.data
        let responseSize = logResponse.size.value
        let responseTime = logResponse.time.toBigInt()
        let logQuantity = UInt64.fromNumber(logs.length).open().value
        let range = BigMath.max(toBlock - fromBlock + 1n, 1n)
        let sizePerBlock = BigMath.max(responseSize / range, 1n)
        let rangeBySize = BigMath.max(
            this._logSizeBorder.value / sizePerBlock, 1n
        )
        let quantityPerBlock = BigMath.max(logQuantity / range, 1n)
        let rangeByQuantity = this._logQuantityBorder.value / quantityPerBlock
        let timespanPerBlock = BigMath.max(responseTime / range, 1n)
        let rangeByTimespan =
            BigInt(this._logTimeBorder.value) / timespanPerBlock
        return {
            bySize: UInt64.fromBigInt(rangeBySize).open(),
            byQuantity: UInt64.fromBigInt(rangeByQuantity).open(),
            byTimespan: UInt64.fromBigInt(rangeByTimespan).open()
        }
    }

    /**
     * @private
     * @param {NodeResponse&lt;LogSegment>} response
     */
    _printLogResponse(response) {
        this._log.info('response size', response.size.format())
        this._log.info('response time', response.time.format())
        this._log.info('response quantity', response.data.logs.length)
    }

    /**
     * @private
     * @param {UInt64} bySize
     * @param {UInt64} byTimespan
     * @param {UInt64} byQuantity
     */
    _printEstimatedLogRange(bySize, byTimespan, byQuantity) {
        this._log.info('estimated log range by size', bySize.format5())
        this._log.info('estimated log range by timespan', byTimespan.format5())
        this._log.info('estimated log range by quantity', byQuantity.format5())
    }

    /**
     * @private
     */
    _updateInternalStat() {
        this._unlockTimestamp()
        this._restoreQuota()
    }

    /**
     * @private
     * @return {undefined}
     */
    _unlockTimestamp() {
        if (this._lockTo === undefined) {
            return
        }
        if (this._lockTo.isPast()) {
            this._lockTo = undefined
        }
    }

    /**
     * @private
     */
    _restoreQuota() {
        if (
            this._nextFillRequests === undefined ||
            this._nextFillRequests.isPresentOrPast()
        ) {
            this._remainRequests = this._batchLimit
            this._nextFillRequests = Timestamp.now().add(this._batchTimespan)
        }
    }

    /**
     * @private
     * @param {BadError} error
     * @param {Timespan} timespan
     */
    _lockTimestampFor(error, timespan) {
        this._lockedByError = error
        if (this._lockTo) {
            return
        }
        this._lockTo = Timestamp.now().add(timespan)
        this._log.error(error.message)
    }

    /**
     * @private
     * @return {Result&lt;undefined>}
     */
    _openTimestampLocker() {
        if (this._lockTo === undefined) {
            return Result.ok()
        }
        return Result.error(this._lockedByError)
    }

    /**
     * @private
     * @param {UInt64} blockNumber
     * @return {Result&lt;TypeError, undefined>}
     */
    _openForSafeBlockNumber(blockNumber) {
        if (blockNumber === undefined) {
            return Result.ok()
        }
        if (this._latestBlockNumber === undefined) {
            return Result.ok()
        }
        if (this._safeBlockNumber === undefined) {
            return Result.badError(NODE_UNSAFE_BLOCK, 'try later')
        }
        if (this._safeBlockNumberTo.isPast()) {
            return Result.ok()
        }
        if (blockNumber.lte(this._safeBlockNumber)) {
            return Result.ok()
        }
        else {
            return Result.badError(NODE_UNSAFE_BLOCK, 'try later')
        }
    }

    /**
     * @private
     * @param {UInt} quantity
     * @return {Result&lt;undefined>}
     */
    _openQuotaLocker(quantity) {
        if (this._remainRequests.lt(quantity)) {
            return Result.badError(NODE_REQUEST_QUOTA, 'try later')
        }
        this._remainRequests = this._remainRequests.sub(quantity)
        return Result.ok()
    }
}

/**
 * Improvement of `Node` without modifications of lower layers of ETH JSON RPC.
 *
 * Firstly, it handles overloading by recognize errors and reduce number of
 * requests or even denie callings in nextime.
 *
 * Secondly, it try to avoid or at least reduce incorrect returned data from RPC
 * methods such as `eth_getLogs`.
 */
class SafeNode {
    /**
     * Host name or IP address that refers to Ethereum endpoint.
     *
     * @type {string}
     */
    get host() {
        return this._node.host
    }

    /**
     * Initialize by {@link SafeNode.create}.
     *
     * @param {object} config
     * @param {Node} config.node
     * @param {RequestValve} config.valve
     * @param {StdioLog} config.log
     */
    constructor(config) {
        let {node, valve, log} = config
        this._node = node
        this._valve = valve
        this._log = log
    }

    /**
     *
     * @param {object} config
     * @param {EthEndpoint} config.endpoint - URL and credentials for
     * connecting to a ETH node.
     * @param {StdioLog} config.log - A log layer.
     * @return {Result&lt;TypeError, SafeNode>}
     */
    static create(config) {
        let r1 = validateInstanceMap(config, [
            ['endpoint', EthEndpoint],
            ['log', StdioLog]
        ])
        if (r1.error) {
            return r1
        }
        let {endpoint, log} = config
        let {url, username, password, timeout} = endpoint
        let nodeEndpoint = HttpEndpoint.create({
            url, username, password, timeout
        }).open()
        let node = Node.create({endpoint: nodeEndpoint}).open()
        let {
            quota, logSafeGap, logRangeBoundary, logSizeBorder, logTimeBorder,
            logQuantityBorder
        } = endpoint
        let valve = RequestValve.create({
            log: log,
            quota: quota,
            logSafeGap: logSafeGap,
            logRangeBoundary: logRangeBoundary,
            logSizeBorder: logSizeBorder,
            logTimeBorder: logTimeBorder,
            logQuantityBorder: logQuantityBorder
        }).open()
        let instance = new SafeNode({node, valve, log})
        return Result.ok(instance)
    }

    /**
     * @return {Promise&lt;Result&lt;BadError, NodeResponse&lt;UInt64>>>}
     */
    async getBlockNumber() {
        let r1 = this._valve.open(UINT_1)
        if (r1.error) {
            return r1
        }
        let r2 = await this._node.getBlockNumber()
        if (r2.error) {
            this._valve.reportError(r2.error)
        }
        return r2
    }

    /**
     * @param {UInt64} blockNumber
     * @return {Promise&lt;Result&lt;BadError, NodeResponse&lt;Block>>>}
     */
    async getBlockByNumber(blockNumber) {
        let r1 = this._valve.open(UINT_1, blockNumber)
        if (r1.error) {
            return r1
        }
        let r2 = await this._node.getBlockByNumber(blockNumber)
        if (r2.error) {
            this._valve.reportError(r2.error)
        }
        return r2
    }

    /**
     *
     * @param {ByteData32} hash
     * @return {Promise&lt;Result&lt;Transaction>>}
     */
    async getTransactionByHash(hash) {
        let r1 = this._valve.open(UINT_1)
        if (r1.error) {
            return r1
        }
        let r2 = await this._node.getTransactionByHash(hash)
        if (r2.error) {
            this._valve.reportError(r2.error)
        }
        return r2
    }

    /**
     *
     * @param {LogFilter} filter
     * @return {Promise&lt;Result&lt;NodeResponse&lt;LogSegment>>>}
     */
    async getLogs(filter) {
        let r1 = this._valve.open(UINT_2, filter.toBlock)
        if (r1.error) {
            return r1
        }
        let r2 = await this._makeSafeLogFilter(filter)
        if (r2.error) {
            this._valve.giveBackQuota(UINT_1)
            this._valve.reportError(r2.error)
            return r2
        }
        let {data: {safeFilter, latestBlock, safeBlock}} = r2
        let r3 = await this._node.getLogs(safeFilter)
        if (r3.error) {
            this._valve.reportError(r3.error)
            return r3
        }
        let {data: nodeResponse} = r3
        let logSegment = LogSegment.create({
            logs: nodeResponse.data,
            fromBlock: safeFilter.fromBlock,
            toBlock: safeFilter.toBlock,
            latestBlock: latestBlock,
            safeBlock: safeBlock
        }).open()
        let data = nodeResponse.cloneWithNewData(logSegment)
        this._valve.updateLogRange(data)
        return Result.ok(data)
    }

    /**
     * Perform a calling to ETH node.
     *
     * @param {string} method - Method to be call, see
     * [ETH JSON RPC](https://eth.wiki/json-rpc/API).
     * @param {Array&lt;any>} params - Positional arguments to pass to method.
     * @return {Promise&lt;Result&lt;BadError, NodeResponse>>}
     */
    async call(method, params) {
        return await this._node.call(method, params)
    }

    /**
     * Return safe block number and latest block nubmer as metadata.
     *
     * @private
     * @return {Promise&lt;Result&lt;BadError, SafeBlockInfo>>}
     */
    async _getSafeBlockInfo() {
        let r1 = await this._node.getBlockNumber()
        if (r1.error) {
            return r1
        }
        let {data: latestBlock} = r1.data
        this._valve.setLatestBlockNumber(latestBlock)
        if (this._valve.safeBlockNumber === undefined) {
            return Result.badError(NODE_UNSAFE_BLOCK, 'try later')
        }
        let instance = {
            latestBlock: latestBlock,
            safeBlock: this._valve.safeBlockNumber.clone()
        }
        return Result.ok(instance)
    }

    /**
     * Build safe log filter, also update safe block number.
     * Returned metadata is latest block number.
     *
     * @private
     * @param {LogFilter} filter
     * @return {Promise&lt;Result&lt;BadError, SafeLogFilter>>}
     */
    async _makeSafeLogFilter(filter) {
        let r1 = await this._getSafeBlockInfo()
        if (r1.error) {
            return r1
        }
        let {safeBlock, latestBlock} = r1.data
        if (safeBlock.lt(filter.fromBlock)) {
            return Result.badError(NODE_UNSAFE_BLOCK, 'try later')
        }
        let estimatedToBlock = filter.fromBlock
            .addPInt64(this._valve.logRange)
            .subNumber(1)
        let toBlock = UInt64.min(estimatedToBlock, filter.toBlock, safeBlock)
        let safeFilter = LogFilter.create({
            fromBlock: filter.fromBlock,
            toBlock: toBlock,
            addresses: filter.addresses,
            topics: filter.topics
        }).open()
        let data = {safeFilter, latestBlock, safeBlock}
        return Result.ok(data)
    }

}

module.exports = {
    SafeNode,
    LogSegment
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Mar 02 2022 17:17:41 GMT+0700 (Indochina Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
