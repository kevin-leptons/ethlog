<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>type.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ChainLocker.html">ChainLocker</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ChainLocker.html#_lockTimestampFor">_lockTimestampFor</a></li><li data-type='method' style='display: none;'><a href="ChainLocker.html#_openQuotaLocker">_openQuotaLocker</a></li><li data-type='method' style='display: none;'><a href="ChainLocker.html#_openSafeBlockNumer">_openSafeBlockNumer</a></li><li data-type='method' style='display: none;'><a href="ChainLocker.html#_openTimestampLocker">_openTimestampLocker</a></li><li data-type='method' style='display: none;'><a href="ChainLocker.html#open">open</a></li><li data-type='method' style='display: none;'><a href="ChainLocker.html#returnQuota">returnQuota</a></li><li data-type='method' style='display: none;'><a href="ChainLocker.html#updateSafeBlockNumber">updateSafeBlockNumber</a></li></ul></li><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Client.html#getBlockByNumber">getBlockByNumber</a></li><li data-type='method' style='display: none;'><a href="Client.html#getBlockNumber">getBlockNumber</a></li><li data-type='method' style='display: none;'><a href="Client.html#getLogs">getLogs</a></li><li data-type='method' style='display: none;'><a href="Client.html#getTransaction">getTransaction</a></li></ul></li><li><a href="Gateway.html">Gateway</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Gateway.html#_pickNode">_pickNode</a></li><li data-type='method' style='display: none;'><a href="Gateway.html#proxy">proxy</a></li></ul></li><li><a href="LogRangeValve.html">LogRangeValve</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_applyNewValue">_applyNewValue</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_getChangeStepValue">_getChangeStepValue</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_isActionDownDown">_isActionDownDown</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_isActionDownUp">_isActionDownUp</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_isActionNone">_isActionNone</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_isActionUpDown">_isActionUpDown</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_isActionUpUp">_isActionUpUp</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_processActionDownDown">_processActionDownDown</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_processActionDownUp">_processActionDownUp</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_processActionNone">_processActionNone</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_processActionUpDown">_processActionUpDown</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_processActionUpUp">_processActionUpUp</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_processNextAction">_processNextAction</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_pushAction">_pushAction</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#_shouldLockUpAction">_shouldLockUpAction</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#down">down</a></li><li data-type='method' style='display: none;'><a href="LogRangeValve.html#up">up</a></li></ul></li><li><a href="LogStream.html">LogStream</a></li><li><a href="Metadata.html">Metadata</a></li><li><a href="module-type-Address.html">Address</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Address.html#.fromHeximal">fromHeximal</a></li><li data-type='method' style='display: none;'><a href="module-type-Address.html#toHeximal">toHeximal</a></li></ul></li><li><a href="module-type-Block.html">Block</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Block.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="module-type-ByteData.html">ByteData</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-ByteData.html#.fromBadHeximal">fromBadHeximal</a></li><li data-type='method' style='display: none;'><a href="module-type-ByteData.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-ByteData32.html">ByteData32</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-ByteData32.html#toHeximal">toHeximal</a></li><li data-type='method' style='display: none;'><a href="module-type-ByteData32.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-DataSize.html">DataSize</a></li><li><a href="module-type-Endpoint.html">Endpoint</a></li><li><a href="module-type-EndpointQuota.html">EndpointQuota</a></li><li><a href="module-type-HttpEndpoint.html">HttpEndpoint</a></li><li><a href="module-type-HttpUrl.html">HttpUrl</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-HttpUrl.html#.fromString">fromString</a></li></ul></li><li><a href="module-type-Log.html">Log</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Log.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="module-type-LogFilter.html">LogFilter</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-LogFilter.html#toRpcInput">toRpcInput</a></li></ul></li><li><a href="module-type-LogTopicCombination.html">LogTopicCombination</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-LogTopicCombination.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="module-type-LogTopicFilter.html">LogTopicFilter</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-LogTopicFilter.html#toRpcInput">toRpcInput</a></li></ul></li><li><a href="module-type-PInt64.html">PInt64</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-PInt64.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-Result.html">Result</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Result.html#.error">error</a></li><li data-type='method' style='display: none;'><a href="module-type-Result.html#.ok">ok</a></li><li data-type='method' style='display: none;'><a href="module-type-Result.html#errorString">errorString</a></li><li data-type='method' style='display: none;'><a href="module-type-Result.html#open">open</a></li></ul></li><li><a href="module-type-ResultError.html">ResultError</a></li><li><a href="module-type-Timespan.html">Timespan</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Timespan.html#.fromMinutes">fromMinutes</a></li><li data-type='method' style='display: none;'><a href="module-type-Timespan.html#.fromSeconds">fromSeconds</a></li></ul></li><li><a href="module-type-Timestamp.html">Timestamp</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Timestamp.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-Transaction.html">Transaction</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Transaction.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="module-type-UInt.html">UInt</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-UInt.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-UInt16.html">UInt16</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-UInt16.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-UInt64.html">UInt64</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-UInt64.html#toHeximal">toHeximal</a></li><li data-type='method' style='display: none;'><a href="module-type-UInt64.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="Node.html">Node</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Node.html#._createHttpClientHeaders">_createHttpClientHeaders</a></li><li data-type='method' style='display: none;'><a href="Node.html#getBlockByNumber">getBlockByNumber</a></li><li data-type='method' style='display: none;'><a href="Node.html#getBlockNumber">getBlockNumber</a></li><li data-type='method' style='display: none;'><a href="Node.html#getLogs">getLogs</a></li><li data-type='method' style='display: none;'><a href="Node.html#getTransactionByHash">getTransactionByHash</a></li></ul></li><li><a href="SafeNode.html">SafeNode</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SafeNode.html#_getSafeBlockNumber">_getSafeBlockNumber</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#_getSafeLogFilter">_getSafeLogFilter</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#getBlockByNumber">getBlockByNumber</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#getBlockNumber">getBlockNumber</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#getLogs">getLogs</a></li><li data-type='method' style='display: none;'><a href="SafeNode.html#getTransactionByHash">getTransactionByHash</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-type.html">type</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type.html#~assertArray">assertArray</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~assertInstance">assertInstance</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~assertObjectAttributes">assertObjectAttributes</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~assertOptionalString">assertOptionalString</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~assertUnsignedInteger">assertUnsignedInteger</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~getHeximalLength">getHeximalLength</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~getInvertedObject">getInvertedObject</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~heximalToFixedBuffer">heximalToFixedBuffer</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~heximalToUnsignedInteger">heximalToUnsignedInteger</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~isObject">isObject</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~validateObjectAttributes">validateObjectAttributes</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~validateUnsignedInteger">validateUnsignedInteger</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#isActionKindDown">isActionKindDown</a></li><li><a href="global.html#isActionKindUp">isActionKindUp</a></li><li><a href="global.html#LogHandler">LogHandler</a></li><li><a href="global.html#LogRangeValveAction">LogRangeValveAction</a></li><li><a href="global.html#LogRangeValveActionKind">LogRangeValveActionKind</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">type.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

/* eslint-disable max-lines-per-function */

/**
 * All types has a default constructor that does not validate input data.
 * This is good for performance from internal code by assume that input data
 * is valid all. Any malformed data is a bug and must be fix.
 *
 * For creating a new instance of type from external data, constructor helpers
 * must be use instead of default constructor. For example `fromNumber()`,
 * `fromHeximal()`. These helper ensures valid data, if not then an error will
 * be throw.
 *
 * For converting to other types, transforming helpers should be used. For
 * example `toHeximal()`, `toRpcInput()`.
 *
 * @module type
 */

/**
 * A heximal string, prefixed `0x` and has at least a heximal digit.
 *
 * @typedef {string} Heximal
 */

/**
 * A heximal string, prefixed `0x`. The value `0x` is valid.
 *
 * @typedef {string} BadHeximal
 */

/**
 * List of error code.
 *
 * @readonly
 * @enum {number}
 */
const ErrorCode = {
    NONE: 0x0,
    TYPE_BAD: 0x0001,
    TYPE_U_INT: 0x0002,
    TYPE_U_INT_OVERFLOW: 0x0003,
    TYPE_U_INT_16_OVERFLOW: 0x0004,
    TYPE_BIG_U_INT: 0x0005,
    TYPE_OPTIONAL_STRING: 0x0006,
    TYPE_ARRAY: 0x0006,
    TYPE_OBJECT: 0x0007,
    TYPE_HEXIMAL: 0x0008,
    TYPE_BUFFER: 0x0009,
    TYPE_URL: 0x000a,
    TYPE_URL_STRING: 0x000b,
    TYPE_PROTOCOL_HTTP: 0x000c,
    TYPE_URL_NO_AUTHENTICATION: 0x000e,
    TYPE_TIMESPAN: 0x000f,
    TYPE_ARRAY_OR_BYTE_DATA_32: 0x0010,
    TYPE_BAD_SIZE: 0x0011,
    TYPE_BAD_RANGE: 0x0012,
    TYPE_HEXIMAL_16_BITS_OVERFLOW: 0x0013,
    TYPE_HEXIMAL_53_BITS_OVERFLOW: 0x0014,
    TYPE_BIG_P_INT: 0x0015,
    TYPE_BUFFER_32_BYTES: 0x0016,
    TYPE_HTTP_URL: 0x0017,
    TYPE_U_INT_64_OVERFLOW: 0x0018,
    TYPE_HEXIMAL_64_BITS_OVERFLOW: 0x0019,

    /**
     * Client should reduce number of requests and data range to server.
     * This error is not always overload from server because there are no
     * explicit clues for confirmation. The reasons can be but not limit:
     * domain name does not exist, IP address is unreachable, server does
     * not serve anything, handshake failure, connection timeout, firewall
     * blocks requests, requests in long queue, server limits client requests.
     */
    ETH_IMPLICIT_OVERLOADING: 0x010000,

    /**
     * Client should reduce number of requests and data range to server
     * immediately because server shows it clearly. This hint come from HTTP
     * layer by status code `429 - Too Many Requests` or
     * `503 - Service Unavailable`.
     */
    ETH_EXPLICIT_OVERLOADING: 0x010001,

    /**
     * Server complains about request data from client because it does not
     * meet specifications. This error is internal of this library and must
     * be fix. If caller has nothing to deal with it then report error and
     * terminate process.
     */
    ETH_BAD_REQUEST: 0x010002,

    /**
     * Server responds bad data which is not in specifications. It come from
     * both HTTP and JSON RPC layer. Client should try later and hope that
     * server is fixed.
     */
    ETH_BAD_RESPONSE: 0x010003,

    /**
     * Server hints that there are errors occurs and it's unable to handle
     * it. Client should try later and hope that server is fixed.
     */
    ETH_BAD_SERVER: 0x010004,
    ETH_NO_BLOCK: 0x010005,
    ETH_NO_TRANSACTION: 0x010006,

    NODE_TIMESTAMP_LOCK: 0x01000001,
    NODE_REQUEST_QUOTA: 0x01000002,
    NODE_UNSAFE_BLOCK: 0x01000003,
    NODE_BAD_SERVER_LOCK: 0x01000004,
    NODE_BAD_RESPONSE_LOCK: 0x01000005,
    NODE_IMPLICIT_OVERLOADING_LOCK: 0x01000006,
    NODE_EXPLICIT_OVERLOADING_LOCK: 0x0001000007,

    GATEWAY_BAD_BACKEND: 0x0100000001,
    GATEWAY_NO_BACKEND: 0x0100000002
}
/**
 * @readonly
 */
const ErrorString = getInvertedObject(ErrorCode)

/**
 * Throw on `Result.open()` or `constructor()`.
 */
class ResultError extends Error {
    /**
     *
     * @param {ErrorCode} error
     * @param {string} hint
     */
    constructor(error, hint) {
        super(ErrorString[error])
        this.error = error
        this.hint = hint
    }
}

/**
 * Result from construction, transform types.
 *
 * @template T - Type of returned data.
 * @template M [undefined] - Type of metadata.
 */
class Result {
    /**
     * @type {ErrorCode}
     */
    get error() {
        return this._error
    }

    /**
     * @type {T}
     */
    get data() {
        return this._data
    }

    /**
     * @type {string}
     */
    get hint() {
        return this._hint
    }

    /**
     * @type {M}
     */
    get metadata() {
        return this._metadata
    }

    /**
     *
     * @param {ErrorCode} error
     * @param {T} data
     * @param {string} hint
     * @param {M} metadata
     */
    constructor(
        error, data = undefined, hint = undefined, metadata = undefined
    ) {
        this._error = error
        this._data = data
        this._hint = hint
        this._metadata = metadata
    }

    /**
     * Force to retrieve data immediately without care about errors.
     *
     * **WARN** This method is design for using in situations such as constant
     * initializaiton, testing, examples or top layers handling. Do not love
     * this one for internal implementations because it breaks error context
     * and handling possibility.
     *
     * @return {T}
     * @throws {ResultError}
     */
    open() {
        let {error, hint, data} = this
        if (error) {
            throw new ResultError(error, this.errorString(), hint)
        }
        return data
    }

    /**
     * Short description of error code.
     *
     * @return {string}
     */
    errorString() {
        return ErrorString[this.error]
    }

    /**
     *
     * @param {T} data
     * @param {M} metadata
     * @return {Result&lt;T, M>}
     */
    static ok(data, metadata = undefined) {
        return new Result(ErrorCode.NONE, data, undefined, metadata)
    }

    /**
     *
     * @param {ErrorCode} code
     * @param {string} hint
     * @return {Result&lt;undefined>}
     */
    static error(code, hint) {
        return new Result(code, undefined, hint)
    }
}

/**
 * Unsigned integer number, 53 bits.
 */
class UInt {
    /**
     * @type {number}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {number} value
     */
    constructor(value) {
        if (!Number.isInteger(value) || value &lt; 0) {
            throw new ResultError(ErrorCode.TYPE_U_INT)
        }
        if (value > Number.MAX_SAFE_INTEGER) {
            throw new ResultError(ErrorCode.TYPE_U_INT_OVERFLOW)
        }
        this._value = value
    }

    /**
     * 53 bits all set heximal: `0x1FFFFFFFFFFFFF`.
     *
     * @param {Heximal} value
     * @return {Result&lt;UInt>}
     */
    static fromHeximal(value) {
        let r1 = heximalToUnsignedInteger(value)
        if (r1.error) {
            return r1
        }
        let {data: number} = r1
        let data = new UInt(number)
        return Result.ok(data)
    }
}

/**
 * Unsigned integer number, 16 bits.
 */
class UInt16 {
    /**
     * Unsigned integer, 16 bits.
     *
     * @type {number}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {number} value
     */
    constructor(value) {
        if (!Number.isInteger(value) || value &lt; 0) {
            throw new ResultError(ErrorCode.TYPE_U_INT)
        }
        if (value > 0xffff) {
            throw new ResultError(ErrorCode.TYPE_U_INT_16_OVERFLOW)
        }
        this._value = value
    }

    /**
     *
     * @param {Heximal} value
     * @return {Result&lt;UInt16>}
     */
    static fromHeximal(value) {
        if (!isHeximal(value)) {
            return Result.error(ErrorCode.TYPE_HEXIMAL)
        }
        let [length] = getHeximalLength(value)
        if (length > 4) {
            return Result.error(ErrorCode.TYPE_HEXIMAL_16_BITS_OVERFLOW)
        }
        let number = Number(value, 16)
        let data = new UInt16(number)
        return Result.ok(data)
    }
}

/**
 * Unsigned integer number, 64 bits.
 */
class UInt64 {
    /**
     * Unsigned integer, 64 bits.
     *
     * @type {bigint}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {bigint} value
     */
    constructor(value) {
        if (
            typeof(value) !== 'bigint' ||
            value &lt; 0
        ) {
            throw new ResultError(ErrorCode.TYPE_BIG_U_INT)
        }
        if (value > 0xffffffffffffffffn) {
            throw new ResultError(ErrorCode.TYPE_U_INT_64_OVERFLOW)
        }
        this._value = value
    }

    /**
     *
     * @return {Heximal}
     */
    toHeximal() {
        return '0x' + this._value.toString(16)
    }

    /**
     *
     * @param {Heximal} value
     * @return {Result&lt;UInt16>}
     */
    static fromHeximal(value) {
        if (!isHeximal(value)) {
            return Result.error(ErrorCode.TYPE_HEXIMAL)
        }
        let [length] = getHeximalLength(value)
        if (length > 16) {
            return Result.error(ErrorCode.TYPE_HEXIMAL_64_BITS_OVERFLOW)
        }
        let number = BigInt(value)
        let data = new UInt64(number)
        return Result.ok(data)
    }
}

/**
 * Possitive integer number, 64 bits.
 */
class PInt64 {
    /**
     * Unsigned integer, 64 bits.
     *
     * @type {bigint}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {bigint} value
     */
    constructor(value) {
        if (
            typeof(value) !== 'bigint' ||
            value &lt;= 0
        ) {
            throw new ResultError(ErrorCode.TYPE_BIG_P_INT)
        }
        if (value > 0xffffffffffffffffn) {
            throw new ResultError(ErrorCode.TYPE_U_INT_64_OVERFLOW)
        }
        this._value = value
    }

    /**
     *
     * @param {Heximal} value
     * @return {Result&lt;UInt16>}
     */
    static fromHeximal(value) {
        if (!isHeximal(value)) {
            return Result.error(ErrorCode.TYPE_HEXIMAL)
        }
        let [length] = getHeximalLength(value)
        if (length > 16) {
            return Result.error(ErrorCode.TYPE_HEXIMAL_64_BITS_OVERFLOW)
        }
        let number = BigInt(value)
        let data = new UInt64(number)
        return Result.ok(data)
    }
}

/**
 * Unix timestamp,, 'transaction' 53 bits.
 */
class Timestamp {
    /**
     * Unix timestamp in miliseconds.
     *
     * @type {number}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {number} value - Unix timestamp in miliseconds.
     */
    constructor(value) {
        assertUnsignedInteger(value)
        this._value = value
    }

    /**
     *
     * @param {Heximal} value
     * @return {Result&lt;Timestamp>}
     */
    static fromHeximal(value) {
        let {error, data: miliseconds} = heximalToUnsignedInteger(value)
        if (error) {
            return Result.error(error)
        }
        let data = new Timestamp(miliseconds)
        return Result.ok(data)
    }
}

/**
 * Time period, 53 bits.
 */
class Timespan {
    /**
     * Time period in miliseconds.
     *
     * @type {number}
     */
    get value() {
        return this._value
    }

    /**
     * @param {number} value - Time period in miliseconds.
     */
    constructor(value) {
        assertUnsignedInteger(value)
        this._value = value
    }

    /**
     * @param {number} value - Time period in seconds.
     * @return {Result&lt;Timestamp>}
     */
    static fromSeconds(value) {
        let r1 = validateUnsignedInteger(value)
        if (r1.error) {
            return r1
        }
        let miliseconds = 1000 * value
        let data = new Timestamp(miliseconds)
        return Result.ok(data)
    }

    /**
     *
     * @param {number} value - Time period in minutes.
     * @return {Result&lt;Timespan>}
     */
    static fromMinutes(value) {
        let r1 = validateUnsignedInteger(value)
        if (r1.error) {
            return r1
        }
        let miliseconds = 1000 * 60 * value
        let data = new Timespan(miliseconds)
        return Result.ok(data)
    }
}

/**
 * Size of data.
 */
class DataSize {
    /**
     * Size of data in bytes.
     *
     * @type {bigint}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {bigint} value - Size of data in bytes.
     */
    constructor(value) {
        if (
            typeof(value) !== 'bigint' ||
            value &lt; 0
        ) {
            throw new ResultError(ErrorCode.TYPE_BIG_U_INT)
        }
        this._value = value
    }
}

/**
 * Array of bytes as a buffer.
 */
class ByteData {
    /**
     * @type {Buffer}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {Buffer} value
     * @throws {Result}
     */
    constructor(value) {
        if ((value instanceof Buffer) === false) {
            throw new ResultError(ErrorCode.TYPE_BUFFER)
        }
        this._value = value
    }

    /**
     *
     * @param {Heximal} value
     * @return {Result&lt;ByteData>}
     */
    static fromHeximal(value) {
        let {error, data: buffer} = heximalToBuffer(value)
        if (error) {
            return Result.error(error)
        }
        let data = new ByteData(buffer)
        return Result.ok(data)
    }

    /**
     * Deal with heximal `0x`, consider it is empty data.
     * Although RPC specification disallows that heximal format, the
     * implementations keep return it somehow.
     *
     * See [HEX value encoding](https://eth.wiki/json-rpc/API)
     * for more details.
     *
     * @param {BadHeximal} value
     * @return {Result&lt;ByteData>}
     */
    static fromBadHeximal(value) {
        let heximal = value === '0x'
            ? '0x0'
            : value
        let {error, data: buffer} = heximalToBuffer(heximal)
        if (error) {
            return Result.error(error)
        }
        let data = new ByteData(buffer)
        return Result.ok(data)
    }
}

/**
 * 32 bytes data.
 */
class ByteData32 {
    /**
     * A buffer, 32 bytes.
     *
     * @type {Buffer}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {Buffer} value - A buffer, 32 bytes.
     * @throws {ResultError}
     */
    constructor(value) {
        if (
            (value instanceof Buffer) === false ||
            value.length !== 32
        ) {
            throw new ResultError(ErrorCode.TYPE_BUFFER_32_BYTES)
        }
        this._value = value
    }

    /**
     *
     * @param {Heximal} value
     * @return {Result&lt;ByteData32>}
     */
    static fromHeximal(value) {
        let {error, data: buffer} = heximalToFixedBuffer(value, 32)
        if (error) {
            return Result.error(error)
        }
        let data = new ByteData32(buffer)
        return Result.ok(data)
    }

    /**
     *
     * @return {Heximal}
     */
    toHeximal() {
        return '0x' + this._value.toString('hex')
    }
}

/**
 * URL has `http` or `https` protocol and has no creadential such as username
 * and password.
 */
class HttpUrl {
    /**
     * @type {URL}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {string} value
     * @throws {Result}
     */
    constructor(value) {
        let url = HttpUrl._parseUrl(value)
        if ((url.protocol !== 'http:') &amp;&amp; (url.protocol !== 'https:')) {
            throw new ResultError(
                ErrorCode.TYPE_PROTOCOL_HTTP, 'expected: http or https'
            )
        }
        if (url.username || url.password) {
            throw new ResultError(
                ErrorCode.TYPE_URL_NO_AUTHENTICATION,
                'expected: no username or password'
            )
        }
        this._value = url
    }

    /**
     *
     * @param {string} value
     * @return {Result&lt;HttpUrl>}
     * @throws {Error}
     */
    static fromString(value) {
        try {
            return new HttpUrl(value)
        }
        catch (error) {
            if (error instanceof Result) {
                return error
            }
            throw error
        }
    }

    /**
     * @private
     * @param {string} value
     * @return {URL}
     * @throws {ResultError}
     */
    static _parseUrl(value) {
        try {
            return new URL(value)
        }
        catch {
            throw new ResultError(ErrorCode.TYPE_URL_STRING)
        }
    }
}

/**
 * Information to interact with HTTP such as URL, authentication.
 */
class HttpEndpoint {
    /**
     * @type {HttpUrl}
     */
    get url() {
        return this._url
    }

    /**
     * @type {Timespan}
     */
    get timeout() {
        return this._timeout
    }

    /**
     * @type {string | undefined}
     */
    get username() {
        return this._username
    }

    /**
     * @type {string | undefined}
     */
    get password() {
        return this._password
    }

    /**
     *
     * @param {object} values
     * @param {HttpUrl} values.url
     * @param {string} [values.username]
     * @param {string} [values.password]
     * @param {Timespan} [values.timeout]
     * @throws {Result}
     */
    constructor(values) {
        assertObjectAttributes(values, [
            'url', 'username', 'password', 'timeout'
        ])
        let {url, username, password, timeout} = values
        timeout = timeout || new Timespan(3000)
        assertInstance(url, HttpUrl, 'url')
        assertOptionalString(username, 'username')
        assertOptionalString(password, 'password')
        assertInstance(timeout, Timespan, 'timeout')
        this._url = url
        this._username = username
        this._password = password
        this._timeout = timeout
    }
}

/**
 * Configuration for a ETH endpoint.
 */
class Endpoint {
    /**
     * @type {HttpUrl}
     */
    get url() {
        return this._url
    }

    /**
     * @type {string | undefined}
     */
    get username() {
        return this._username
    }

    /**
     * @type {string | undefined}
     */
    get password() {
        return this._password
    }

    /**
     * @type {Timespan}
     */
    get timeout() {
        return this._timeout
    }

    /**
     * @type {EndpointQuota}
     */
    get quota() {
        return this._quota
    }

    /**
     * @type {UInt64}
     */
    get safeBlockGap() {
        return this._safeBlockGap
    }

    /**
     *
     * @param {object} values
     * @param {HttpUrl} values.url
     * @param {string} [values.username]
     * @param {string} [values.password]
     * @param {Timespan} [values.timeout]
     * @param {EndpointQuota} [values.quota]
     * @param {UInt64} [values.safeBlockGap]
     * @throws {Result}
     */
    constructor(values) {
        assertObjectAttributes(values, [
            'url', 'username', 'password', 'timeout', 'safeBlockGap'
        ])
        let {url, username, password, timeout, quota, safeBlockGap} = values
        timeout = timeout || new Timespan(3000)
        quota = quota || new EndpointQuota()
        safeBlockGap = safeBlockGap || new UInt64(15n)
        assertInstance(url, HttpUrl, 'vaues.url')
        assertOptionalString(username, 'username')
        assertOptionalString(username, 'password')
        assertInstance(timeout, Timespan, 'timeout')
        assertInstance(quota, EndpointQuota, 'quota')
        assertInstance(safeBlockGap, UInt64, 'safeBlockGap')
        this._url = url
        this._username = username
        this._password = password
        this._timeout = timeout
        this._quota = quota || new EndpointQuota()
        this._safeBlockGap = safeBlockGap || new UInt64(15n)
    }
}

/**
 * Specific limits of a endpoint.
 */
class EndpointQuota {
    /**
     * @type {UInt}
     */
    get batchLimit() {
        return this._batchLimit
    }

    /**
     * @type {Timespan}
     */
    get batchTimespan() {
        return this._batchTimespan
    }

    /**
     *
     * @param {object} values
     * @param {UInt} [values.batchLimit] - Maximum allowd number of request in
     * a timespan. If this value is set then `batchTimespan` must be set too.
     * If this value is not set then `batchTimespan` is ignored.
     * @param {Timespan} [values.batchTimespan] - How long a batch limit is
     * apply for in miliseconds.
     */
    constructor(values = {}) {
        assertObjectAttributes(values, ['batchLimit', 'batchTimespan'])
        let {batchLimit, batchTimespan} = values
        batchLimit = batchLimit || new UInt(1)
        batchTimespan = batchTimespan || new Timespan(1000)
        assertInstance(batchLimit, UInt, 'batchLimit')
        assertInstance(batchTimespan, Timespan, 'batchTimespan')
        this._batchLimit = batchLimit
        this._batchTimespan = batchTimespan
    }
}

/**
 * ETH address, 20 bytes.
 */
class Address {
    /**
     * 20 bytes buffer.
     *
     * @type {Buffer}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {Buffer} value
     */
    constructor(value) {
        if ((value instanceof Buffer) === false) {
            throw new ResultError(ErrorCode.TYPE_BUFFER)
        }
        if (value.length !== 20) {
            throw new ResultError(ErrorCode.TYPE_BAD_SIZE, '20 bytes')
        }
        this._value = value
    }

    /**
     *
     * @return {string}
     */
    toHeximal() {
        return '0x' + this._value.toString('hex')
    }

    /**
     *
     * @param {Heximal} value
     * @return {Result&lt;Address>}
     */
    static fromHeximal(value) {
        let r1 = heximalToFixedBuffer(value, 20)
        if (r1.error) {
            return r1
        }
        let {data: buffer} = r1
        let data = new Address(buffer)
        return Result.ok(data)
    }
}

/**
 * ETH block.
 */
class Block {
    /**
     * Ordered number of the block.
     *
     * @type {UInt64}
     */
    get number() {
        return this._number
    }

    /**
     * Timestamp when block is mined.
     *
     * @type {Timestamp}
     */
    get timestamp() {
        return this._timestamp
    }

    /**
     * List of transaction hashes.
     *
     * @type {Array&lt;ByteData32>}
     */
    get transactions() {
        return this._transactions
    }

    /**
     *
     * @param {object} values
     * @param {UInt64} values.number
     * @param {Timestamp} values.timestamp
     * @param {Array&lt;ByteData32>} values.transactions
     * @throws {Result}
     */
    constructor(values) {
        assertObjectAttributes(values, ['number', 'timestamp', 'transactions'])
        let {number, timestamp, transactions} = values
        assertInstance(number, UInt64, 'number')
        assertInstance(timestamp, Timestamp, 'timestamp')
        assertArray(transactions, 'transactions')
        transactions.forEach((item, index) => {
            assertInstance(item, ByteData32, `transactions[${index}]`)
        })
        this._number = number
        this._timestamp = timestamp
        this._transactions = transactions
    }

    /**
     *
     * @param {any} values
     * @return {Result&lt;Block>}
     */
    static fromRpcResult(values) {
        if (!isObject(values)) {
            return Result.error(ErrorCode.TYPE_OBJECT, 'values')
        }
        let {error: e1, data: number} = UInt64.fromHeximal(values.number)
        if (e1) {
            return Result.error(e1, 'number')
        }
        let {error: e2, data: timestamp} = Timestamp.fromHeximal(
            values.timestamp
        )
        if (e2) {
            return Result.error(e2, 'timestamp')
        }
        if (!Array.isArray(values.transactions)) {
            return Result.error(
                ErrorCode.TYPE_ARRAY, 'transactions'
            )
        }
        let transactions = []
        for (let [i, v] of values.transactions.entries()) {
            let {error: e3, data: tx} = ByteData32.fromHeximal(v)
            if (e3) {
                return Result.error(e3, `transactions[${i}]`)
            }
            transactions.push(tx)
        }
        let block = new Block({number, timestamp, transactions})
        return Result.ok(block)
    }
}

/**
 * ETH transaction.
 */
class Transaction {
    /**
     * @type {ByteData32}
     */
    get hash() {
        return this._hash
    }

    /**
     * @type {Address}
     */
    get from() {
        return this._from
    }

    /**
     * @type {Address}
     */
    get to() {
        return this._to
    }

    /**
     * @type {UInt64}
     */
    get blockNumber() {
        return this._blockNumber
    }

    /**
     * @type {UInt16}
     */
    get transactionIndex() {
        return this._transactionIndex
    }

    /**
     *
     * @param {object} values
     * @param {ByteData32} values.hash
     * @param {Address} values.from
     * @param {Address} values.to
     * @param {UInt64} values.blockNumber
     * @param {UInt16} values.transactionIndex
     */
    constructor(values) {
        assertObjectAttributes(values, [
            'hash', 'from', 'to', 'blockNumber', 'transactionIndex'
        ])
        let {hash, from, to, blockNumber, transactionIndex} = values
        assertInstance(hash, ByteData32, 'hash')
        assertInstance(from, Address, 'from')
        assertInstance(to, Address, 'to')
        assertInstance(blockNumber, UInt64, 'blockNumber')
        assertInstance(transactionIndex, UInt16, 'transactionIndex')
        this._hash = hash
        this._from = from
        this._to = to
        this._blockNumber = blockNumber
        this._transactionIndex = transactionIndex
    }

    /**
     *
     * @param {object} values - Result from RPC.
     * @return {Result&lt;Transaction>}
     */
    static fromRpcResult(values) {
        if (!isObject(values)) {
            return Result.error(ErrorCode.TYPE_OBJECT, 'values')
        }
        let {error: e1, data: hash} = ByteData32.fromHeximal(values.hash)
        if (e1) {
            return Result.error(e1, 'hash')
        }
        let {error: e2, data: from} = Address.fromHeximal(values.from)
        if (e2) {
            return Result.error(e2, 'from')
        }
        let {error: e3, data: to} = Address.fromHeximal(values.to)
        if (e3) {
            return Result.error(e3, 'to')
        }
        let {error: e4, data: blockNumber} = UInt64.fromHeximal(
            values.blockNumber
        )
        if (e4) {
            return Result.error(e4, 'blockNumber')
        }
        let {error: e5, data: transactionIndex} = UInt16.fromHeximal(
            values.transactionIndex
        )
        if (e5) {
            return Result.error(e5, 'transactionIndex')
        }
        let transaction = new Transaction({
            hash, from, to, blockNumber, transactionIndex
        })
        return Result.ok(transaction)
    }
}

/**
 * An array contains at most 4 log topics.
 */
class LogTopicCombination {
    /**
     * @type {Array&lt;ByteData32>}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {Array&lt;ByteData32>} value
     */
    constructor(value) {
        assertArray(value)
        if (value.length > 4) {
            throw new ResultError(ErrorCode.TYPE_BAD_SIZE, 'at most 4')
        }
        value.forEach((v, i) => {
            assertInstance(v, ByteData32, `value[${i}]`)
        })
        this._value = value
    }

    /**
     *
     * @param {Array&lt;Heximal>} value
     * @return {Result&lt;LogTopicCombination>}
     */
    static fromRpcResult(value) {
        if (!Array.isArray(value)) {
            return Result.error(ErrorCode.TYPE_ARRAY, 'value')
        }
        if (value.length > 4) {
            return Result.error(ErrorCode.TYPE_BAD_SIZE, 'expected: at most 4')
        }
        let topics = []
        for (let [i, v] of value.entries()) {
            let {error, data: topic} = ByteData32.fromHeximal(v)
            if (error) {
                return Result.error(error, `value: ${i}`)
            }
            topics.push(topic)
        }
        let combination = new LogTopicCombination(topics)
        return Result.ok(combination)
    }
}

/**
 * Topics filter for retrieving logs.
 * See [Log Filters](https://docs.ethers.io/v5/concepts/events/)
 * for more details.
 */
class LogTopicFilter {
    /**
     * @type {Array&lt;ByteData32 | Array&lt;ByteData32>>}
     */
    get value() {
        return this._value
    }

    /**
     *
     * @param {Array&lt;ByteData32 | Array&lt;ByteData32>>} value
     */
    constructor(value = []) {
        assertArray(value)
        if (value.length > 4) {
            throw new ResultError(ErrorCode.TYPE_BAD_SIZE, 'expected: &lt;= 4')
        }
        for (let [i, v] of value.entries()) {
            if (!LogTopicFilter._isArrayOrByteData32(v)) {
                throw new ResultError(
                    ErrorCode.TYPE_ARRAY_OR_BYTE_DATA_32, `value[${i}]`
                )
            }
        }
        this._value = value
    }

    /**
     * Transform to data that works as JSON RPC input.
     *
     * @return {Array&lt;Heximal | Array&lt;Heximal>>}
     */
    toRpcInput() {
        return this._value.map(item => {
            if (item instanceof ByteData32) {
                return item.toHeximal()
            }
            else {
                return item.map(child => child.toHeximal())
            }
        })
    }

    /**
     * @private
     * @param {ByteData32 | Array&lt;ByteData32>} value
     * @return {boolean}
     */
    static _isArrayOrByteData32(value) {
        return (value instanceof ByteData32) ||
            LogTopicFilter._isByteData32Array(value)
    }

    /**
     * @private
     * @param {Array&lt;ByteData32>} value
     * @return {boolean}
     */
    static _isByteData32Array(value) {
        if (!Array.isArray(value)) {
            return false
        }
        for (let item of value) {
            if ((item instanceof ByteData32) === false) {
                return false
            }
        }
        return true
    }
}

/**
 * Specify conditions for fetching logs.
 */
class LogFilter {
    /**
     * @type {UInt64}
     */
    get fromBlock() {
        return this._fromBlock
    }

    /**
     * @type {UInt64}
     */
    get toBlock() {
        return this._toBlock
    }

    /**
     * @type {Array&lt;Address>}
     */
    get addresses() {
        return this._addresses
    }

    /**
     * @type {LogTopicFilter}
     */
    get topics() {
        return this._topics
    }

    /**
     *
     * @param {object} values
     * @param {UInt64} values.fromBlock
     * @param {UInt64} values.toBlock
     * @param {Array&lt;Address>} [values.addresses]
     * @param {LogTopicFilter} [values.topics]
     */
    constructor(values) {
        assertObjectAttributes(values, [
            'fromBlock', 'toBlock', 'addresses', 'topics'
        ])
        let {fromBlock, toBlock, addresses, topics} = values
        addresses = addresses || []
        topics = topics || new LogTopicFilter()
        assertInstance(fromBlock, UInt64, 'fromBlock')
        assertInstance(toBlock, UInt64, 'toBlock')
        assertArray(addresses)
        addresses.forEach((v, i) => {
            assertInstance(v, Address, `addresses[${i}]`)
        })
        assertInstance(topics, LogTopicFilter, 'topics')
        if (fromBlock.value > toBlock.value) {
            throw new ResultError(
                ErrorCode.TYPE_BAD_RANGE, 'expected: fromBlock > toBlock'
            )
        }
        this._fromBlock = fromBlock
        this._toBlock = toBlock
        this._addresses = addresses
        this._topics = topics
    }

    /**
     * Transform to data that works as JSON RPC input.
     *
     * @return {object}
     */
    toRpcInput() {
        return {
            fromBlock: this._fromBlock.toHeximal(),
            toBlock: this._toBlock.toHeximal(),
            address: this._addresses.map(item => item.toHeximal()),
            topics: this._topics.toRpcInput()
        }
    }
}

/**
 * A log record from EVM.
 */
class Log {
    /**
     * @type {Address}
     */
    get address() {
        return this._address
    }

    /**
     * @type {UInt64}
     */
    get blockNumber() {
        return this._blockNumber
    }

    /**
     * @type {UInt16}
     */
    get logIndex() {
        return this._logIndex
    }

    /**
     * @type {UInt16}
     */
    get transactionIndex() {
        return this._transactionIndex
    }

    /**
     * @type {LogTopicCombination}
     */
    get topics() {
        return this._topics
    }

    /**
     * @type {ByteData}
     */
    get data() {
        return this._data
    }

    /**
     * @type {ByteData32}
     */
    get blockHash() {
        return this._blockHash
    }

    /**
     * @type {ByteData32}
     */
    get transactionHash() {
        return this._transactionHash
    }

    /**
     *
     * @param {object} values
     * @param {Address} values.address - Contract that emits log.
     * @param {UInt64} values.blockNumber - Block number that contains log.
     * @param {UInt16} values.logIndex - Order of the log in block.
     * @param {UInt16} values.transactionIndex - Order of transaction that
     * emits log.
     * @param {LogTopicCombination} values.topics - List of log topics.
     * @param {ByteData} values.data - Related data, could be decode by ABI.
     * @param {ByteData32} values.blockHash - Hash of block that contains log.
     * @param {ByteData32} values.transactionHash - Hash of transaction
     * that emits log.
     */
    constructor(values) {
        assertObjectAttributes(values, [
            'address', 'blockNumber', 'logIndex', 'transactionIndex', 'topics',
            'data', 'blockHash', 'transactionHash'
        ])
        let {
            address, blockNumber, logIndex, transactionIndex,
            topics, data, blockHash, transactionHash
        } = values
        assertInstance(address, Address, 'address')
        assertInstance(blockNumber, UInt64, 'blockNumber')
        assertInstance(logIndex, UInt16, 'logIndex')
        assertInstance(transactionIndex, UInt16, 'transactionIndex')
        assertInstance(topics, LogTopicCombination, 'topics')
        assertInstance(data, ByteData, 'data')
        assertInstance(blockHash, ByteData32, 'blockHash')
        assertInstance(transactionHash, ByteData32, 'transactionHash')
        this._address = address
        this._blockNumber = blockNumber
        this._logIndex = logIndex
        this._transactionIndex = transactionIndex
        this._topics = topics
        this._data = data
        this._blockHash = blockHash
        this._transactionHash = transactionHash
    }

    /**
     *
     * @param {object} values
     * @return {Result&lt;Log>}
     */
    static fromRpcResult(values) {
        if (!isObject(values)) {
            return Result.error(ErrorCode.TYPE_OBJECT, 'values')
        }
        let {error: e1, data: address} = Address.fromHeximal(values.address)
        if (e1) {
            return Result.error(e1, 'address')
        }
        let {error: e2, data: blockNumber} = UInt64.fromHeximal(
            values.blockNumber
        )
        if (e2) {
            return Result.error(e2, 'blockNumber')
        }
        let {error: e3, data: logIndex} = UInt16.fromHeximal(values.logIndex)
        if (e3) {
            return Result.error(e3, 'logIndex')
        }
        let {error: e4, data: transactionIndex} = UInt16.fromHeximal(
            values.transactionIndex
        )
        if (e4) {
            return Result.error(e4, 'transactionIndex')
        }
        let {error: e5, data: topics} = LogTopicCombination.fromRpcResult(
            values.topics
        )
        if (e5) {
            return Result.error(e5, 'topics')
        }
        let {error: e6, data: data} = ByteData.fromBadHeximal(values.data)
        if (e6) {
            return Result.error(e6, 'data')
        }
        let {error: e7, data: blockHash} = ByteData32.fromHeximal(
            values.blockHash
        )
        if (e7) {
            return Result.error(e7, 'blockHash')
        }
        let {error: e8, data: transactionHash} = ByteData32.fromHeximal(
            values.transactionHash
        )
        if (e8) {
            return Result.error(e8, 'transactionHash')
        }
        let log = new Log({
            address, blockNumber, logIndex, transactionIndex, topics,
            data, blockHash, transactionHash
        })
        return Result.ok(log)
    }
}

/**
 * Return a new object A, where `A[v] = k`, `k` is a property name form input
 * object `object` and `v = object[k]`.
 *
 * @param {object} object
 * @return {object}
 */
function getInvertedObject(object) {
    let names = Object.getOwnPropertyNames(object)
    let result = {}
    for (let name of names) {
        let code = object[name]
        result[code] = name
    }
    return result
}

/**
 * @param {Heximal} value
 * @return {Array&lt;number, number>} First item is number of significant heximal
 * digits, second item is first significant digit.
 */
function getHeximalLength(value) {
    for (let i = 2; i &lt; value.length; ++i) {
        if (value[i] !== '0') {
            return [value.length - i, value[i]]
        }
    }
    return [0, undefined]
}

/**
 * Transform heximal to 53 bits unsigned integer number.
 *
 * @param {Heximal} value
 * @return {Result&lt;number>}
 */
function heximalToUnsignedInteger(value) {
    if (!isHeximal(value)) {
        return Result.error(ErrorCode.TYPE_HEXIMAL)
    }
    let [length, digit] = getHeximalLength(value)
    if (
        (length > 14) ||
        (length === 14 &amp;&amp; digit > '1')
    ) {
        return Result.error(ErrorCode.TYPE_HEXIMAL_53_BITS_OVERFLOW)
    }
    let number = Number(value, 16)
    return Result.ok(number)
}

/**
 * Check a value is safe, unsigned, integer number in Javasript.
 *
 * @private
 * @param {number} value
 * @return {boolean}
 */
function isUnsignedInteger(value) {
    return Number.isInteger(value) &amp;&amp;
        (value >= 0) &amp;&amp;
        (value &lt;= Number.MAX_SAFE_INTEGER)
}

/**
 *
 * @param {object} value
 * @return {boolean}
 */
function isObject(value) {
    return (typeof(value) === 'object') &amp;&amp; (value !== null)
}

/**
 * @private
 * @param {any} value
 * @return {boolean}
 */
function isHeximal(value) {
    return /^0x[a-fA-F0-9]+$/.test(value)
}

/**
 * @private
 * @param {Heximal} value
 * @return {Result&lt;Buffer>}
 */
function heximalToBuffer(value) {
    if (!isHeximal(value)) {
        return Result.error(ErrorCode.TYPE_HEXIMAL)
    }
    let hasEvenLength = (value.length % 2) === 0
    let evenHeximal = hasEvenLength
        ? value.slice(2)
        : '0' + value.slice(2)
    let buffer = Buffer.from(evenHeximal, 'hex')
    return Result.ok(buffer)
}

/**
 * @param {Heximal} value
 * @param {number} size - Number of bytes.
 * @return {Result&lt;Buffer>}
 */
function heximalToFixedBuffer(value, size) {
    if (!isUnsignedInteger(size)) {
        return Result.error(ErrorCode.TYPE_U_INT)
    }
    if (!isHeximal(value)) {
        return Result.error(ErrorCode.TYPE_HEXIMAL)
    }
    let digits = value.slice(2)
    if (digits.length !== (2 * size)) {
        return Result.error(ErrorCode.TYPE_BAD_SIZE, `${size} bytes`)
    }
    let buffer = Buffer.from(digits, 'hex')
    return Result.ok(buffer)
}

/**
 *
 * @param {number} value
 * @return {Result}
 */
function validateUnsignedInteger(value) {
    if (!Number.isInteger(value) || value &lt; 0) {
        return Result.error(ErrorCode.TYPE_U_INT)
    }
    if (value > Number.MAX_SAFE_INTEGER) {
        return Result.error(ErrorCode.TYPE_U_INT_OVERFLOW)
    }
    return Result.ok()
}

/**
 *
 * @param {object} value
 * @param {Array&lt;string>} acceptedAttributes
 * @return {Result&lt;undefined>}
 */
function validateObjectAttributes(value, acceptedAttributes = []) {
    if (typeof value !== 'object' || value === null) {
        return Result.error(ErrorCode.TYPE_OBJECT)
    }
    let attributes = Object.getOwnPropertyNames(value)
    let acceptedAttributeSet = new Set(acceptedAttributes)
    for (let attribute of attributes) {
        if (!acceptedAttributeSet.has(attribute)) {
            return Result.error(
                ErrorCode.NOT_ACCEPTED_ATTRIBUTE, undefined, attribute
            )
        }
    }
    return Result.ok(ErrorCode.NONE)
}

/**
 *
 * @param {number} value
 * @throws {Result}
 */
function assertUnsignedInteger(value) {
    if (!Number.isInteger(value) || value &lt; 0) {
        throw new ResultError(ErrorCode.TYPE_U_INT)
    }
    if (value > Number.MAX_SAFE_INTEGER) {
        throw new ResultError(ErrorCode.TYPE_U_INT_OVERFLOW)
    }
}

/**
 *
 * @param {object} value
 * @param {Array&lt;string>} attributes - Accepted attributes.
 * @throws {Result}
 */
function assertObjectAttributes(value, attributes = []) {
    let result = validateObjectAttributes(value, attributes)
    if (result.error) {
        throw result
    }
}

/**
 *
 * @param {string | undefined} value
 * @param {string} hint
 * @throws {Result}
 */
function assertOptionalString(value, hint = '_') {
    if (typeof(value) === 'string' || value === undefined) {
        return
    }
    throw new ResultError(ErrorCode.TYPE_OPTIONAL_STRING, hint)
}

/**
 *
 * @param {any} value
 * @param {Function} type
 * @param {string} identity
 * @throws {Result}
 */
function assertInstance(value, type, identity) {
    if ((value instanceof type) === false) {
        throw new ResultError(
            ErrorCode.TYPE_BAD, `${identity} must be ${type.name}`
        )
    }
}

/**
 *
 * @param {Array} value
 * @throws {Result}
 */
function assertArray(value) {
    if (!Array.isArray(value)) {
        throw new ResultError(ErrorCode.TYPE_ARRAY)
    }
}

module.exports = {
    ErrorCode,
    ErrorString,
    ResultError,
    Result,
    UInt,
    UInt16,
    UInt64,
    PInt64,
    Timestamp,
    Timespan,
    DataSize,
    ByteData,
    ByteData32,
    HttpUrl,
    HttpEndpoint,
    Endpoint,
    EndpointQuota,
    Address,
    Block,
    Transaction,
    LogTopicCombination,
    LogTopicFilter,
    LogFilter,
    Log,
    getInvertedObject,
    validateObjectAttributes,
    heximalToFixedBuffer,
    assertObjectAttributes,
    assertInstance,
    assertArray
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Tue Jan 11 2022 08:05:02 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
