<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>type.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Address.html">Address</a><ul class='methods'><li data-type='method'><a href="Address.html#.assertInstance">assertInstance</a></li><li data-type='method'><a href="Address.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="Block.html">Block</a><ul class='methods'><li data-type='method'><a href="Block.html#.assertInstance">assertInstance</a></li><li data-type='method'><a href="Block.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="BlockHash.html">BlockHash</a><ul class='methods'><li data-type='method'><a href="BlockHash.html#.assertInstance">assertInstance</a></li><li data-type='method'><a href="BlockHash.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="ByteArray.html">ByteArray</a><ul class='methods'><li data-type='method'><a href="ByteArray.html#.assertInstance">assertInstance</a></li><li data-type='method'><a href="ByteArray.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="DataError.html">DataError</a><ul class='methods'><li data-type='method'><a href="DataError.html#.throw">throw</a></li></ul></li><li><a href="Log.html">Log</a><ul class='methods'><li data-type='method'><a href="Log.html#.assertInstance">assertInstance</a></li><li data-type='method'><a href="Log.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="LogFilter.html">LogFilter</a><ul class='methods'><li data-type='method'><a href="LogFilter.html#.assertInstance">assertInstance</a></li></ul></li><li><a href="LogTopicCombination.html">LogTopicCombination</a><ul class='methods'><li data-type='method'><a href="LogTopicCombination.html#.assertInstance">assertInstance</a></li></ul></li><li><a href="Node.html">Node</a><ul class='methods'><li data-type='method'><a href="Node.html#_requestJsonRpc">_requestJsonRpc</a></li><li data-type='method'><a href="Node.html#getBlockByNumber">getBlockByNumber</a></li><li data-type='method'><a href="Node.html#getBlockNumber">getBlockNumber</a></li><li data-type='method'><a href="Node.html#getLogs">getLogs</a></li><li data-type='method'><a href="Node.html#getTransactionByHash">getTransactionByHash</a></li></ul></li><li><a href="Timestamp.html">Timestamp</a><ul class='methods'><li data-type='method'><a href="Timestamp.html#.assertInstance">assertInstance</a></li><li data-type='method'><a href="Timestamp.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="TransactionHash.html">TransactionHash</a><ul class='methods'><li data-type='method'><a href="TransactionHash.html#.assertInstance">assertInstance</a></li><li data-type='method'><a href="TransactionHash.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="UBigInt.html">UBigInt</a><ul class='methods'><li data-type='method'><a href="UBigInt.html#.assertInstance">assertInstance</a></li><li data-type='method'><a href="UBigInt.html#.fromHeximal">fromHeximal</a></li><li data-type='method'><a href="UBigInt.html#toHeximal">toHeximal</a></li></ul></li><li><a href="UInt.html">UInt</a><ul class='methods'><li data-type='method'><a href="UInt.html#.assertInstance">assertInstance</a></li><li data-type='method'><a href="UInt.html#.fromHeximal">fromHeximal</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#getUnkownAttribute">getUnkownAttribute</a></li><li><a href="global.html#Heximal">Heximal</a></li><li><a href="global.html#heximalToBigInt">heximalToBigInt</a></li><li><a href="global.html#heximalToBuffer">heximalToBuffer</a></li><li><a href="global.html#heximalToNumber">heximalToNumber</a></li><li><a href="global.html#isAbi">isAbi</a></li><li><a href="global.html#isEthAddressHeximal">isEthAddressHeximal</a></li><li><a href="global.html#isHeximal">isHeximal</a></li><li><a href="global.html#isPositiveInteger">isPositiveInteger</a></li><li><a href="global.html#isTransactionHashHeximal">isTransactionHashHeximal</a></li><li><a href="global.html#isUint">isUint</a></li><li><a href="global.html#isUnsignedInteger">isUnsignedInteger</a></li><li><a href="global.html#isValidEndpoint">isValidEndpoint</a></li><li><a href="global.html#isValidHttpUrl">isValidHttpUrl</a></li><li><a href="global.html#NodeConfig">NodeConfig</a></li><li><a href="global.html#numberToHeximal">numberToHeximal</a></li><li><a href="global.html#standardizeConfig">standardizeConfig</a></li><li><a href="global.html#uIntToHeximal">uIntToHeximal</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">type.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

/**
 * A number as heximal string, prefixed `0x`.
 * 
 * @typedef {string} Heximal
 */

/**
 * Report on any data error, include but not limit: type, format, range.
 */
class DataError extends Error {
    /**
     * 
     * @param {string} message 
     * @param {Error} originError 
     */
    constructor(message, originError=undefined) {
        super(message)
        this.name = 'DataError'
        this._originError = originError
    }

    /**
     * @type {Error}
     */
    get originError() {
        return this._originError
    }

    /**
     * 
     * @param {string} message 
     * @param {Error} originError 
     */
    static throw(message, originError) {
        throw new DataError(message, originError)
    }
}

/**
 * Unsigned 53 bits integer.
 */
class UInt {
    constructor(value) {
        if (!Number.isInteger(value) || value &lt; 0) {
            DataError.throw('not unsigned integer number: value')
        }
        this._value = value
    }

    /**
     * @type {number}
     */
    get value() {
        return this._value
    }

    /**
     * 
     * @param {Heximal} value 
     * @returns {UInt}
     */
    static fromHeximal(value) {
        let number = heximalToNumber(value)
        return new UInt(number)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
     static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof UInt) === false) {
            DataError.throw('not a UInt: ' + hint)
        }
    }
}

/**
 * Unsigned, big integer number.
 */
class UBigInt {
    /**
     * 
     * @param {BigInt | number} value - Unsigned, integer number.
     * @throws {DataError}
     */
    constructor(value) {
        if (Number.isInteger(value) &amp;&amp; value >= 0) {
            this._value = BigInt(value)
            return
        }
        if (typeof value !== 'bigint' || value >= 0) {
            this._value = BigInt(value)
            return
        }
        DataError.throw('not a unsigned BigInt: value')
    }

    /**
     * @type {BigInt}
     */
    get value() {
        return this._value
    }

    /**
     * @returns {Heximal}
     */
    toHeximal() {
        return '0x' + this._value.toString(16)
    }

    /**
     * 
     * @param {Heximal} value - Heximal string, prefixed `0x`.
     * @returns {UBigInt}
     * @throws {DataError}
     */
    static fromHeximal(value) {
        let number = heximalToBigInt(value)
        return new UBigInt(number)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
     static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof UBigInt) === false) {
            DataError.throw('not a UBigInt: ' + hint)
        }
    }
}

/**
 * Unix timestmap in seconds.
 */
class Timestamp {
    /**
     * 
     * @param {number} value - Unix timestamp in seconds.
     * @throws {DataError}
     */
    constructor(value) {
        if (!Number.isInteger(value) || value &lt; 0) {
            DataError.throw('not a unsigned integer: value')
        }
        this._value = value
    }

    /**
     * Unix timestamp in seconds.
     * 
     * @type {number}
     */
    get value() {
        return this._value
    }

    /**
     * 
     * @param {Heximal} value 
     * @returns {Timestamp}
     * @throws {DataError}
     */
    static fromHeximal(value) {
        let number = heximalToNumber(value)
        return new Timestamp(number)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
    static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof Timestamp) === false) {
            DataError.throw('not a Timestamp: ' + hint)
        }
    }
}

/**
 * Array of bytes as a buffer.
 */
class ByteArray {
    /**
     * 
     * @param {Buffer} value 
     */
    constructor(value) {
        if ((value instanceof Buffer) === false) {
            DataError.throw('not a buffer: value')
        }
        this._value = value
    }

    /**
     * @type {Buffer}
     */
    get value() {
        return this._value
    }

    /**
     * 
     * @param {Heximal} value 
     * @returns {ByteArray}
     */
    static fromHeximal(value) {
        let buffer = heximalToBuffer(value)
        return new ByteArray(buffer)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
    static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof ByteArray) === false) {
            DataError.throw('not a ByteArray: ' + hint)
        }
    }
}

/**
 * ETH address, 20 bytes.
 */
class Address {
    /**
     * 
     * @param {Buffer} value 
     */
    constructor(value) {
        if (
            (value instanceof Buffer) === false ||
            value.length !== 20
        ) {
            DataError.throw('not a 20 bytes buffer: value')
        }
        this._value = value
    }

    /**
     * 20 bytes buffer as address.
     * 
     * @type {Buffer}
     */
    get value() {
        return this._value
    }

    /**
     * 
     * @param {Heximal} value 
     * @returns {Address}
     */
    static fromHeximal(value) {
        if (!isHeximal(value) || value.length !== 42) {
            DataError.throw('not a 20 bytes heximal: value')
        }
        let buffer = heximalToBuffer(value)
        return new Address(buffer)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
    static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof Address) === false) {
            DataError.throw('not a Address: ' + hint)
        }
    }
}

/**
 * 32 bytes, has of a block.
 */
class BlockHash {
    /**
     * 
     * @param {Buffer} value - 32 bytes buffer.
     */
    constructor(value) {
        if (value.length !== 32) {
            DataError.throw('not a 32 bytes heximal: value')
        }
        this._value = value
    }

    /**
     * 32 bytes buffer.
     * 
     * @type {Buffer}
     */
    get value() {
        return this._value
    }

    /**
     * 
     * @param {Heximal} value 
     * @returns {BlockHash}
     */
    static fromHeximal(value) {
        let buffer = heximalToBuffer(value)
        return new BlockHash(buffer)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
    static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof BlockHash) === false) {
            DataError.throw('not a BlockHash: ' + hint)
        }
    }
}

/**
 * 32 bytes, hash of a transaction.
 */
class TransactionHash {
    /**
     * 
     * @param {Buffer} value - 32 bytes buffer.
     */
    constructor(value) {
        if (value.length !== 32) {
            DataError.throw('not a 32 bytes heximal: value')
        }
        this._value = value
    }

    /**
     * 32 bytes buffer.
     * 
     * @type {Buffer}
     */
    get value() {
        return this._value
    }

    /**
     * 
     * @param {Heximal} value 
     * @returns {TransactionHash}
     */
    static fromHeximal(value) {
        let buffer = heximalToBuffer(value)
        return new TransactionHash(buffer)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
    static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof TransactionHash) === false) {
            DataError.throw('not a TransactionHash: ' + hint)
        }
    }
}

class Block {
    /**
     * 
     * @param {object} value
     * @param {UBigInt} value.number
     * @param {Timestamp} value.timestamp
     * @param {Array&lt;TransactionHash>} value.transactions
     * @
     */
    constructor(value) {
        if (typeof value !== 'object') {
            DataError.throw('not an object: value')
        }
        let {number, timestamp, transactions} = value
        if (!UBigInt.isInstance(number)) {
            DataError.throw('not a UBigInt: value.number')
        }
        if (!Timestamp.isInstance(timestamp)) {
            DataError.throw('not a timestamp: value.timestamp')
        }
        if (!Array.isArray(transactions)) {
            DataError.throw('not an array: value.transactions')
        }
        transactions.forEach((item, index) => {
            if (!TransactionHash.isInstance(item)) {
                DataError.throw(
                    `not a transaction hash: value.transactions[${index}]`
                )
            }
        })
        this._number = number
        this._timestamp = timestamp
        this._transactions = transactions
    }

    /**
     * Ordered number of the block.
     * 
     * @type {UBigInt}
     */
    get number() {
        return this._number
    }

    /**
     * Timestamp when block is mined.
     * 
     * @type {Timestamp}
     */
    get timestamp() {
        return this._timestamp
    }

    /**
     * List of transaction hashes.
     * 
     * @type {Array&lt;TransactionHash>}
     */
    get transactions() {
        return this._transactions
    }

    /**
     * 
     * @param {any} value 
     * @returns {Block}
     */
    static fromRpcResult(value) {
        if (!value) {
            DataError.throw('not an object: value')
        }
        if (!Array.isArray(value.transactions)) {
            DataError.throw('not an array: value.transactions')
        }
        let block = {
            number: UBigInt.fromHeximal(value.number),
            timestamp: Timestamp.fromHeximal(value.timestamp),
            transactions: value.transactions.map(TransactionHash.fromHeximal)
        }
        return new Block(block)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
    static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof Block) === false) {
            DataError.throw('not a Block: ' + hint)
        }
    }
}

/**
 * Combination of four ETH topics.
 */
class LogTopicCombination {
    /**
     * 
     * @param {Array} value
     */
    constructor(value) {
        this._value = value
    }

    /**
     * @type {Array}
     */
    get values() {
        return this._value
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
    static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof LogTopicCombination) === false) {
            DataError.throw('not a LogTopicCombination: ' + hint)
        }
    }
}

/**
 * Specific logs for fetching from a node.
 */
class LogFilter {
    constructor(value) {
        if (typeof value !== 'object') {
            DataError.throw('not an object: value')
        }
        if (!Array.isArray(value.addresses)) {
            DataError.throw('not an array: value.addresses')
        }
        this._fromBlock = new UInt(value.fromBlock)
        this._toBlock = new UInt(value.toBlock)
        this._addresses = value.addresses.map(Address.fromHeximal)
        this._topics = LogTopicCombination.fromArray(value.topics)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
    static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof LogFilter) === false) {
            DataError.throw('not a LogFilter: ' + hint)
        }
    }
}

/**
 * A log record from EVM.
 */
class Log {
    constructor(value) {
        if (typeof value !== 'object') {
            DataError.throw('not an object: value')
        }
        let {
            address,
            blockNumber,
            logIndex,
            transactionIndex,
            topics,
            data,
            blockHash,
            transactionHash
        } = value
        Address.assertInstance(address, 'value.address')
        UBigInt.assertInstance(blockNumber, 'value.blockNumber')
        UInt.assertInstance(logIndex, 'value.logIndex')
        UInt.assertInstance(transactionIndex, 'value.transactionIndex')
        LogTopicCombination.assertInstance(topics, 'value.topics')
        BlockHash.assertInstance(blockHash, 'value.blockHash')
        TransactionHash.assertInstance(
            transactionHash, 
            'value.transactionHash'
        )
    }

    /**
     * 
     * @param {object} value 
     * @returns {Log}
     * @throws {DataError}
     */
    static fromRpcResult(value) {
        if (typeof value !== 'object') {
            DataError.throw('not an object: value')
        }
        let data = {
            address: Address.fromHeximal(value.address),
            blockNumber: UBigInt.fromHeximal(value.blockNumber),
            logIndex: UInt.fromHeximal(value.logIndex),
            transactionIndex: UInt.fromHeximal(value.transactionIndex),
            topics: LogTopicCombination.fromRpcResult(value.topics),
            data: ByteArray.fromHeximal(data),
            blockHash: BlockHash.fromHeximal(value.blockHash),
            transactionHash: TransactionHash.fromHeximal(value.transactionHash)
        }
        return new Log(data)
    }

    /**
     * 
     * @param {any} value 
     * @param {string} hint
     * @throws {DataError}
     */
    static assertInstance(value, hint='oops!, no more information') {
        if ((value instanceof Log) === false) {
            DataError.throw('not a Log: ' + hint)
        }
    }
}

/**
 * 
 * @param {any} value 
 * @returns {boolean}
 */
function isHeximal(value) {
    return /^0x[a-fA-F0-9]+$/.test(value)
}

/**
 * @param {any} value 
 * @returns {number}
 * @throws {DataError}
 */
function heximalToNumber(value) {
    if (!isHeximal(value)) {
        DataError.throw('not a heximal: value')
    }
    let number = BigInt(value)
    if (number > Number.MAX_SAFE_INTEGER) {
        DataError.throw('overflow native Javascript integer number: value')
    }
    return Number(number)
}

/**
 * 
 * @param {any} value 
 * @returns {BigInt}
 * @throws {DataError}
 */
function heximalToBigInt(value) {
    if (!isHeximal(value)) {
        DataError.throw('not a heximal: value')
    }
    return BigInt(value)
}

/**
 * 
 * @param {any} value 
 * @returns {Buffer}
 * @throws {DataError}
 */
function heximalToBuffer(value) {
    if (!isHeximal(value)) {
        DataError.throw('not a heximal: vavlue')
    }
    let evenLength = (value.length % 2) === 0
    let evenHeximal = evenLength
        ? value.slice(2)
        : '0x' + value.slice(2)
    return Buffer.from(evenHeximal, 'hex')
}

module.exports = {
    DataError,
    UBigInt,
    Timestamp,
    TransactionHash,
    Block,
    LogFilter,
    Log
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Tue Jan 04 2022 03:56:36 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
