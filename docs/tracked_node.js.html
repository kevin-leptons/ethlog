<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>tracked_node.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Client.html#getLogs">getLogs</a></li></ul></li><li><a href="ClientLayer1.html">ClientLayer1</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClientLayer1.html#getLogs">getLogs</a></li></ul></li><li><a href="ClientLayer2.html">ClientLayer2</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClientLayer2.html#getLogs">getLogs</a></li></ul></li><li><a href="ClientLayer3.html">ClientLayer3</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClientLayer3.html#getLogs">getLogs</a></li></ul></li><li><a href="Gateway.html">Gateway</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Gateway.html#pick">pick</a></li></ul></li><li><a href="Metadata.html">Metadata</a></li><li><a href="module-type-Address.html">Address</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Address.html#.fromHeximal">fromHeximal</a></li><li data-type='method' style='display: none;'><a href="module-type-Address.html#toHeximal">toHeximal</a></li></ul></li><li><a href="module-type-BigUInt.html">BigUInt</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-BigUInt.html#.fromHeximal">fromHeximal</a></li><li data-type='method' style='display: none;'><a href="module-type-BigUInt.html#toHeximal">toHeximal</a></li></ul></li><li><a href="module-type-Block.html">Block</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Block.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="module-type-ByteData.html">ByteData</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-ByteData.html#.fromBadHeximal">fromBadHeximal</a></li><li data-type='method' style='display: none;'><a href="module-type-ByteData.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-ByteData32.html">ByteData32</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-ByteData32.html#toHeximal">toHeximal</a></li><li data-type='method' style='display: none;'><a href="module-type-ByteData32.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-DataSize.html">DataSize</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-DataSize.html#.fromNumber">fromNumber</a></li></ul></li><li><a href="module-type-EndpointQuota.html">EndpointQuota</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-EndpointQuota.html#.fromValues">fromValues</a></li></ul></li><li><a href="module-type-HttpEndpoint.html">HttpEndpoint</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-HttpEndpoint.html#.fromValues">fromValues</a></li></ul></li><li><a href="module-type-HttpUrl.html">HttpUrl</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-HttpUrl.html#.fromString">fromString</a></li></ul></li><li><a href="module-type-Log.html">Log</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Log.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="module-type-LogFilter.html">LogFilter</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-LogFilter.html#.fromValues">fromValues</a></li><li data-type='method' style='display: none;'><a href="module-type-LogFilter.html#toRpcInput">toRpcInput</a></li></ul></li><li><a href="module-type-LogSegment.html">LogSegment</a></li><li><a href="module-type-LogTopicCombination.html">LogTopicCombination</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-LogTopicCombination.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="module-type-LogTopicFilter.html">LogTopicFilter</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-LogTopicFilter.html#.fromArray">fromArray</a></li><li data-type='method' style='display: none;'><a href="module-type-LogTopicFilter.html#toRpcInput">toRpcInput</a></li></ul></li><li><a href="module-type-Result.html">Result</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Result.html#.error">error</a></li><li data-type='method' style='display: none;'><a href="module-type-Result.html#.ok">ok</a></li><li data-type='method' style='display: none;'><a href="module-type-Result.html#errorString">errorString</a></li><li data-type='method' style='display: none;'><a href="module-type-Result.html#open">open</a></li></ul></li><li><a href="module-type-ResultError.html">ResultError</a></li><li><a href="module-type-Timespan.html">Timespan</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Timespan.html#.fromNumber">fromNumber</a></li></ul></li><li><a href="module-type-Timestamp.html">Timestamp</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Timestamp.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-Transaction.html">Transaction</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-Transaction.html#.fromRpcResult">fromRpcResult</a></li></ul></li><li><a href="module-type-UInt.html">UInt</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-UInt.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="module-type-UInt16.html">UInt16</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type-UInt16.html#.fromHeximal">fromHeximal</a></li></ul></li><li><a href="Node.html">Node</a><ul class='methods'><li data-type='method' style='display: none;'><a href="Node.html#getBlockNumber">getBlockNumber</a></li></ul></li><li><a href="ResourceLocker.html">ResourceLocker</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ResourceLocker.html#assertConsumption">assertConsumption</a></li><li data-type='method' style='display: none;'><a href="ResourceLocker.html#lockFor">lockFor</a></li></ul></li><li><a href="Result.html">Result</a></li><li><a href="TrackedNode.html">TrackedNode</a><ul class='methods'><li data-type='method' style='display: none;'><a href="TrackedNode.html#_assertBlockNumber">_assertBlockNumber</a></li><li data-type='method' style='display: none;'><a href="TrackedNode.html#_handleTrackedNodeError">_handleTrackedNodeError</a></li><li data-type='method' style='display: none;'><a href="TrackedNode.html#getBlockByNumber">getBlockByNumber</a></li><li data-type='method' style='display: none;'><a href="TrackedNode.html#getBlockNumber">getBlockNumber</a></li><li data-type='method' style='display: none;'><a href="TrackedNode.html#getLogs">getLogs</a></li><li data-type='method' style='display: none;'><a href="TrackedNode.html#getTransactionByHash">getTransactionByHash</a></li></ul></li><li><a href="TrackedNodeError.html">TrackedNodeError</a></li></ul><h3>Modules</h3><ul><li><a href="module-type.html">type</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-type.html#~getHeximalLength">getHeximalLength</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~getInvertedObject">getInvertedObject</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~heximalToFixedBuffer">heximalToFixedBuffer</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~heximalToUnsignedInteger">heximalToUnsignedInteger</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~isObject">isObject</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~isOptionalString">isOptionalString</a></li><li data-type='method' style='display: none;'><a href="module-type.html#~validateObject">validateObject</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#ErrorCode">ErrorCode</a></li><li><a href="global.html#getUnkownAttribute">getUnkownAttribute</a></li><li><a href="global.html#heximalToBigInt">heximalToBigInt</a></li><li><a href="global.html#heximalToNumber">heximalToNumber</a></li><li><a href="global.html#isAbi">isAbi</a></li><li><a href="global.html#isEthAddressHeximal">isEthAddressHeximal</a></li><li><a href="global.html#isHeximal">isHeximal</a></li><li><a href="global.html#isPositiveInteger">isPositiveInteger</a></li><li><a href="global.html#isTransactionHashHeximal">isTransactionHashHeximal</a></li><li><a href="global.html#isUint">isUint</a></li><li><a href="global.html#isUnsignedInteger">isUnsignedInteger</a></li><li><a href="global.html#isValidEndpoint">isValidEndpoint</a></li><li><a href="global.html#isValidHttpUrl">isValidHttpUrl</a></li><li><a href="global.html#numberToHeximal">numberToHeximal</a></li><li><a href="global.html#uIntToHeximal">uIntToHeximal</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">tracked_node.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const {ProtocolError, Node} = require('./node')
const {
    DataError,
    NotExistedError,
    UInt,
    BigUInt,
    HttpEndpoint,
    EndpointQuota,
    Block,
    LogFilter,
    LogSegment,
    TransactionHash,
    Transaction,
    assertConfigObject
} = require('./type')

class TrackedNodeError extends Error {
    static CODE_NO_RESOURCE = 1

    static CODE_NO_SAFE_BLOCK = 2

    /**
     *
     * @param {number} code - One of constants `TrackedNodeError.CODE_*`.
     * @param {string} message
     * @param {Error} cause
     */
    constructor(code, message, cause) {
        super(message)
        this.name = 'TrackedNodeError'
        this._code = code
        this._cause = cause
    }

    /**
     * @type {number}
     */
    get code() {
        return this._code
    }

    /**
     * @type {Error}
     */
    get cause() {
        return this._cause
    }
}

/**
 * Ensure a lock for resource, base on timestamp and quantity.
 */
class ResourceLocker {
    /**
     *
     * @param {object} config
     * @param {EndpointQuota} config.quota
     */
    constructor(config) {
        assertConfigObject(config, 'config', ['quota'])
        let {quota} = config
        EndpointQuota.assertInstance(quota, 'cofig.quota')
        this._quota = quota
        this._remainQuantity = this._quota.batchLimit.value
        this._nextFillTimestamp = Date.now() + this._quota.batchTimespan.value
        this._lockToTimestamp = undefined
    }

    /**
     * Ensure resource is available and there is enough quantity. If calling
     * successfully then resource is reduce by `quantity`.
     *
     * @param {UInt} quantity - Number of request for consumption.
     * @throws {TrackedNodeError}
     */
    assertConsumption(quantity) {
        UInt.assertInstance(quantity, 'quantity')
        let now = Date.now()
        if (this._lockToTimestamp &amp;&amp; now &lt; this._lockToTimestamp) {
            throw new TrackedNodeError(
                TrackedNodeError.CODE_NO_RESOURCE, 'locked by timestamp'
            )
        }
        if (now >= this._nextFillTimestamp) {
            this._remainQuantity = this._quota.batchLimit.value
            this._nextFillTimestamp = Date.now() +
                this._quota.batchTimespan.value
        }
        let remain = this._remainQuantity - quantity.value
        if (remain &lt; 0) {
            throw new TrackedNodeError(
                TrackedNodeError.CODE_NO_RESOURCE, 'out of quota'
            )
        }
        this._remainQuantity = remain
    }

    /**
     * Lock in time range [now, now + timespan]. If there is already lock then
     * override it. This call locks resource even resource quantity is
     * available.
     *
     * @param {UInt} timespan - Time period in miliseconds.
     */
    lockFor(timespan) {
        this._lockToTimestamp = Date.now() + timespan
    }
}

/**
 * Improvement of `Node` without modifications of lower layers of ETH JSON RPC.
 *
 * Firstly, it handles overloading by recognize errors and reduce number of
 * requests or even denie callings in nextime.
 *
 * Secondly, it try to avoid or at least reduce incorrect returned data from RPC
 * methods such as `eth_getLogs`.
 */
class TrackedNode {
    /**
     *
     * @param {object} config
     * @param {HttpEndpoint} config.endpoint
     * @param {EndpointQuota} config.quota
     * @param {UInt} [config.timeout]
     * @param {BigUInt} [config.blockGap]
     * @throws {DataError}
     */
    constructor(config) {
        assertConfigObject(config, 'config', ['endpoint', 'timeout', 'quota'])
        let {endpoint, quota, timeout, blockGap} = config
        HttpEndpoint.assertInstance(endpoint, 'config.endpoint')
        EndpointQuota.assertInstance(quota, 'config.quota')
        timeout = timeout || new UInt(3000)
        UInt.assertInstance(timeout, 'config.timeout')
        blockGap = blockGap || new BigUInt(15)
        BigUInt.assertInstance(blockGap, 'config.blockGap')
        this._blockGap = blockGap
        this._node = new Node({endpoint, timeout})
        this._locker = new ResourceLocker({quota: quota})
    }

    /**
     * @type {BigUInt}
     */
    _blockGap

    /**
     * @type {Node}
     */
    _node

    /**
     * @type {ResourceLocker}
     */
    _locker

    /**
     * Latest block number which is update by last call such as
     * `getBlockNumber()` or `getLogs()`.
     *
     * @type {BigUInt}
     */
    _blockNumber

    /**
     * @type {UInt}
     */
    _blockNumberLockTo

    /**
     * @returns {BigUInt}
     * @throws {TrackedNodeError | ProtocolError}
     */
    async getBlockNumber() {
        this._locker.assertConsumption(1)
        try {
            this._blockNumber = await this._node.getBlockNumber()
            return this._blockNumber
        }
        catch (error) {
            this._handleNodeError(error)
        }
    }

    /**
     * @param {BigUInt} blockNumber
     * @returns {Block}
     * @throws {DataError | TrackedNodeError | NotExistedError | ProtocolError}
     */
    async getBlockByNumber(blockNumber) {
        this._locker.assertConsumption(1)
        try {
            return await this._node.getBlockByNumber(blockNumber)
        }
        catch (error) {
            this._handleNodeError(error)
        }
    }

    /**
     *
     * @param {LogFilter} filter
     * @returns {Array&lt;LogSegment>}
     * @throws {DataError | TrackedNodeError | ProtocolError}
     */
    async getLogs(filter) {
        this._locker.assertConsumption(
            new UInt(2)
        )
        this._assertBlockNumber(filter.toBlock)
        try {
            this._blockNumber = await this._node.getBlockNumber()
            let safeBlockNumber = this._blockNumber.value -
                this._blockGap.value
            if (safeBlockNumber &lt; filter.fromBlock.value) {
                throw new TrackedNodeError(
                    TrackedNodeError.CODE_NO_SAFE_BLOCK,
                    'no safe block for log records'
                )
            }
            let toBlock = filter.toBlock.value &lt; safeBlockNumber
                ? filter.toBlock
                : new BigUInt(safeBlockNumber)
            let safeFilter = new LogFilter({
                fromBlock: filter.fromBlock,
                toBlock: toBlock,
                addresses: filter.addresses,
                topics: filter.topics
            })
            let logs = await this._node.getLogs(safeFilter)
            return new LogSegment(logs, toBlock)
        }
        catch (error) {
            this._handleNodeError(error)
        }
    }

    /**
     *
     * @param {TransactionHash} hash
     * @returns {Transaction}
     * @throws {DataError | TrackedNodeError | NotExistedError | ProtocolError}
     */
    async getTransactionByHash(hash) {
        this._locker.assertConsumption(1)
        try {
            return await this._node.getTransactionByHash(hash)
        }
        catch (error) {
            this._handleNodeError(error)
        }
    }

    /**
     *
     * @param {BigUInt} blockNumber
     * @throws {CODE_NO_SAFE_BLOCK}
     */
    _assertBlockNumber(blockNumber) {
        return this._blockNumber >= blockNumber ||
            this._blockNumberLockTo &lt; Date.now()
    }

    /**
     * @private
     * @param {DataError | NotExistedError | ProtocolError} error - Error which
     * is throws from `Node`.
     * @throws {DataError | NotExistedError | ProtocolError}
     */
    _handleNodeError(error) {
        if (error instanceof ProtocolError) {
            this._handleProtocolError(error)
        }
        else if (error instanceof TrackedNodeError) {
            this._handleTrackedNodeError(error)
        }
        else {
            throw error
        }
    }

    /**
     * @private
     * @param {ProtocolError} error
     * @throws {ProtocolError} - Error which must be fixed.
     */
    _handleProtocolError(error) {
        switch (error.code) {
            case ProtocolError.CODE_IMPLICIT_OVERLOAD:
                this._locker.lockFor(3000)
                throw error
            case ProtocolError.CODE_EXPLICIT_OVERLOAD:
                this._locker.lockFor(6000)
                throw error
            case ProtocolError.CODE_BAD_SERVER:
                this._locker.lockFor(60000)
                throw error
            case ProtocolError.CODE_BAD_RESPONSE:
                this._locker.lockFor(60000)
                throw error
            case ProtocolError.CODE_BAD_REQUEST:
                throw error
            default:
                throw error
        }
    }

    /**
     *
     * @param {TrackedNodeError} error
     * @throws {TrackedNodeError}
     */
    _handleTrackedNodeError(error) {
        switch (error.code) {
            case TrackedNodeError.CODE_NO_SAFE_BLOCK:
                this._lockFor(3000)
                throw error
            default:
                throw error
        }
    }

    _lockFor(miliseconds) {
        this._blockNumberLockTo = Date.now() + miliseconds
    }
}

module.exports = {
    TrackedNodeError,
    TrackedNode
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Sat Jan 08 2022 21:38:47 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
